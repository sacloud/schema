// Package main provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/pkg/errors"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// APIError defines model for APIError.
type APIError struct {
	ErrorCode string `json:"error_code"`
	ErrorMsg  string `json:"error_msg"`
	IsFatal   bool   `json:"is_fatal"`
	Serial    string `json:"serial"`
	Status    string `json:"status"`
}

// ActionResultEnvelope defines model for ActionResultEnvelope.
type ActionResultEnvelope struct {
	IsOk bool `json:"is_ok"`
}

// FTPServer defines model for FTPServer.
type FTPServer struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// FindRequest defines model for FindRequest.
type FindRequest struct {
	Count   *int      `json:"Count,omitempty"`
	Exclude *[]string `json:"Exclude,omitempty"`
	From    *int      `json:"From,omitempty"`
	Include *[]string `json:"Include,omitempty"`
	Sort    *[]string `json:"Sort,omitempty"`
}

// FindResultEnvelope defines model for FindResultEnvelope.
type FindResultEnvelope struct {
	Count int  `json:"Count"`
	From  int  `json:"From"`
	Total int  `json:"Total"`
	IsOk  bool `json:"is_ok"`
}

// ID defines model for ID.
type ID interface{}

// Icon defines model for Icon.
type Icon struct {
	Availability string    `json:"Availability"`
	CreatedAt    time.Time `json:"CreatedAt"`
	ID           ID        `json:"ID"`
	ModifiedAt   time.Time `json:"ModifiedAt"`
	Name         string    `json:"Name"`
	Scope        string    `json:"Scope"`
	Tags         []string  `json:"Tags"`
	URL          string    `json:"URL"`
}

// IconCreateRequest defines model for IconCreateRequest.
type IconCreateRequest struct {
	Icon IconCreateRequestBody `json:"Icon"`
}

// IconCreateRequestBody defines model for IconCreateRequestBody.
type IconCreateRequestBody struct {
	Image string    `json:"Image"`
	Name  string    `json:"Name"`
	Tags  *[]string `json:"Tags,omitempty"`
}

// IconFindFilter defines model for IconFindFilter.
type IconFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	Scope                *Scope                 `json:"Scope,omitempty"`
	TagsName             *[]string              `json:"Tags.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconFindRequest defines model for IconFindRequest.
type IconFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *IconFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconMultiResponse defines model for IconMultiResponse.
type IconMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconsWrapper)
	IconsWrapper `yaml:",inline"`
}

// IconSingleResponse defines model for IconSingleResponse.
type IconSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconWrapper)
	IconWrapper `yaml:",inline"`
}

// IconUpdateRequest defines model for IconUpdateRequest.
type IconUpdateRequest struct {
	Icon IconUpdateRequestBody `json:"Icon"`
}

// IconUpdateRequestBody defines model for IconUpdateRequestBody.
type IconUpdateRequestBody struct {
	Name *string   `json:"Name,omitempty"`
	Tags *[]string `json:"Tags,omitempty"`
}

// IconWrapper defines model for IconWrapper.
type IconWrapper struct {
	Icon Icon `json:"Icon"`
}

// Icons defines model for Icons.
type Icons []struct {
	// Embedded struct due to allOf(#/components/schemas/Icon)
	Icon `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// IconsWrapper defines model for IconsWrapper.
type IconsWrapper struct {
	Icons Icons `json:"Icons"`
}

// Region defines model for Region.
type Region struct {
	Description string   `json:"Description"`
	ID          int      `json:"ID"`
	Name        string   `json:"Name"`
	NameServers []string `json:"NameServers"`
}

// RegionFindFilter defines model for RegionFindFilter.
type RegionFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionFindRequest defines model for RegionFindRequest.
type RegionFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *RegionFindFilter      `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionMultiResponse defines model for RegionMultiResponse.
type RegionMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionsWrapper)
	RegionsWrapper `yaml:",inline"`
}

// RegionSingleResponse defines model for RegionSingleResponse.
type RegionSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionWrapper)
	RegionWrapper `yaml:",inline"`
}

// RegionWrapper defines model for RegionWrapper.
type RegionWrapper struct {
	Region Region `json:"Region"`
}

// Regions defines model for Regions.
type Regions []struct {
	// Embedded struct due to allOf(#/components/schemas/Region)
	Region `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// RegionsWrapper defines model for RegionsWrapper.
type RegionsWrapper struct {
	Regions Regions `json:"Regions"`
}

// Scope defines model for Scope.
type Scope string

// List of Scope
const (
	Scope_shared Scope = "shared"
	Scope_user   Scope = "user"
)

// VNCProxy defines model for VNCProxy.
type VNCProxy struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// Zone defines model for Zone.
type Zone struct {
	CreatedAt    time.Time `json:"CreatedAt"`
	Description  string    `json:"Description"`
	DisplayOrder int       `json:"DisplayOrder"`
	FTPServer    FTPServer `json:"FTPServer"`
	ID           ID        `json:"ID"`
	IsDummy      bool      `json:"IsDummy"`
	Name         string    `json:"Name"`
	Region       Region    `json:"Region"`
	VNCProxy     VNCProxy  `json:"VNCProxy"`
}

// ZoneFindFilter defines model for ZoneFindFilter.
type ZoneFindFilter struct {
	ID                   *[]string              `json:"ID,omitempty"`
	Name                 *[]string              `json:"Name,omitempty"`
	RegionID             *[]string              `json:"Region.ID,omitempty"`
	RegionName           *[]string              `json:"Region.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneFindRequest defines model for ZoneFindRequest.
type ZoneFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *ZoneFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneMultiResponse defines model for ZoneMultiResponse.
type ZoneMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZonesWrapper)
	ZonesWrapper `yaml:",inline"`
}

// ZoneSingleResponse defines model for ZoneSingleResponse.
type ZoneSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZoneWrapper)
	ZoneWrapper `yaml:",inline"`
}

// ZoneWrapper defines model for ZoneWrapper.
type ZoneWrapper struct {
	Zone Zone `json:"Zone"`
}

// Zones defines model for Zones.
type Zones []struct {
	// Embedded struct due to allOf(#/components/schemas/Zone)
	Zone `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// ZonesWrapper defines model for ZonesWrapper.
type ZonesWrapper struct {
	Zones Zones `json:"Zones"`
}

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError APIError

// UnexpectedError defines model for UnexpectedError.
type UnexpectedError APIError

// CreateIconsJSONBody defines parameters for CreateIcons.
type CreateIconsJSONBody IconCreateRequest

// UpdateIconByIdJSONBody defines parameters for UpdateIconById.
type UpdateIconByIdJSONBody IconUpdateRequest

// CreateIconsJSONRequestBody defines body for CreateIcons for application/json ContentType.
type CreateIconsJSONRequestBody CreateIconsJSONBody

// UpdateIconByIdJSONRequestBody defines body for UpdateIconById for application/json ContentType.
type UpdateIconByIdJSONRequestBody UpdateIconByIdJSONBody

// Getter for additional properties for IconFindFilter. Returns the specified
// element and whether it was found
func (a IconFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindFilter
func (a *IconFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a *IconFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Scope"]; found {
		err = json.Unmarshal(raw, &a.Scope)
		if err != nil {
			return errors.Wrap(err, "error reading 'Scope'")
		}
		delete(object, "Scope")
	}

	if raw, found := object["Tags.Name"]; found {
		err = json.Unmarshal(raw, &a.TagsName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Tags.Name'")
		}
		delete(object, "Tags.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a IconFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.Scope != nil {
		object["Scope"], err = json.Marshal(a.Scope)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Scope'"))
		}
	}

	if a.TagsName != nil {
		object["Tags.Name"], err = json.Marshal(a.TagsName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Tags.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IconFindRequest. Returns the specified
// element and whether it was found
func (a IconFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindRequest
func (a *IconFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a *IconFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a IconFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindFilter. Returns the specified
// element and whether it was found
func (a RegionFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindFilter
func (a *RegionFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a *RegionFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a RegionFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindRequest. Returns the specified
// element and whether it was found
func (a RegionFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindRequest
func (a *RegionFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a *RegionFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a RegionFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindFilter. Returns the specified
// element and whether it was found
func (a ZoneFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindFilter
func (a *ZoneFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a *ZoneFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ID"]; found {
		err = json.Unmarshal(raw, &a.ID)
		if err != nil {
			return errors.Wrap(err, "error reading 'ID'")
		}
		delete(object, "ID")
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Region.ID"]; found {
		err = json.Unmarshal(raw, &a.RegionID)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.ID'")
		}
		delete(object, "Region.ID")
	}

	if raw, found := object["Region.Name"]; found {
		err = json.Unmarshal(raw, &a.RegionName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.Name'")
		}
		delete(object, "Region.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a ZoneFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ID != nil {
		object["ID"], err = json.Marshal(a.ID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'ID'"))
		}
	}

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.RegionID != nil {
		object["Region.ID"], err = json.Marshal(a.RegionID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.ID'"))
		}
	}

	if a.RegionName != nil {
		object["Region.Name"], err = json.Marshal(a.RegionName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindRequest. Returns the specified
// element and whether it was found
func (a ZoneFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindRequest
func (a *ZoneFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a *ZoneFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a ZoneFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateIcons request  with any body
	CreateIconsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIcons(ctx context.Context, body CreateIconsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIconById request
	DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowIconById request
	ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIcons request
	ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowRegionById request
	ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegions request
	ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowZoneById request
	ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListZones request
	ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateIconsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIcons(ctx context.Context, body CreateIconsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequestWithBody(c.Server, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequest(c.Server, iconId, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIconsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRegionByIdRequest(c.Server, regionId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowZoneByIdRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateIconsRequest calls the generic CreateIcons builder with application/json body
func NewCreateIconsRequest(server string, body CreateIconsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIconsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIconsRequestWithBody generates requests for CreateIcons with any type of body
func NewCreateIconsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIconByIdRequest generates requests for DeleteIconById
func NewDeleteIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowIconByIdRequest generates requests for ShowIconById
func NewShowIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIconByIdRequest calls the generic UpdateIconById builder with application/json body
func NewUpdateIconByIdRequest(server string, iconId ID, body UpdateIconByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIconByIdRequestWithBody(server, iconId, "application/json", bodyReader)
}

// NewUpdateIconByIdRequestWithBody generates requests for UpdateIconById with any type of body
func NewUpdateIconByIdRequestWithBody(server string, iconId ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIconsRequest generates requests for ListIcons
func NewListIconsRequest(server string, params IconFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowRegionByIdRequest generates requests for ShowRegionById
func NewShowRegionByIdRequest(server string, regionId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "regionId", regionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string, params RegionFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowZoneByIdRequest generates requests for ShowZoneById
func NewShowZoneByIdRequest(server string, zoneId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "zoneId", zoneId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListZonesRequest generates requests for ListZones
func NewListZonesRequest(server string, params ZoneFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	req = req.WithContext(ctx)
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateIcons request  with any body
	CreateIconsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconsResponse, error)

	CreateIconsWithResponse(ctx context.Context, body CreateIconsJSONRequestBody) (*CreateIconsResponse, error)

	// DeleteIconById request
	DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error)

	// ShowIconById request
	ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error)

	UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error)

	// ListIcons request
	ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error)

	// ShowRegionById request
	ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error)

	// ListRegions request
	ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error)

	// ShowZoneById request
	ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error)

	// ListZones request
	ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error)
}

type CreateIconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r CreateIconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r DeleteIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListIconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowRegionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowRegionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowRegionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowZoneByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowZoneByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowZoneByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateIconsWithBodyWithResponse request with arbitrary body returning *CreateIconsResponse
func (c *ClientWithResponses) CreateIconsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconsResponse, error) {
	rsp, err := c.CreateIconsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconsResponse(rsp)
}

func (c *ClientWithResponses) CreateIconsWithResponse(ctx context.Context, body CreateIconsJSONRequestBody) (*CreateIconsResponse, error) {
	rsp, err := c.CreateIcons(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconsResponse(rsp)
}

// DeleteIconByIdWithResponse request returning *DeleteIconByIdResponse
func (c *ClientWithResponses) DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error) {
	rsp, err := c.DeleteIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIconByIdResponse(rsp)
}

// ShowIconByIdWithResponse request returning *ShowIconByIdResponse
func (c *ClientWithResponses) ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error) {
	rsp, err := c.ShowIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseShowIconByIdResponse(rsp)
}

// UpdateIconByIdWithBodyWithResponse request with arbitrary body returning *UpdateIconByIdResponse
func (c *ClientWithResponses) UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconByIdWithBody(ctx, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconById(ctx, iconId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

// ListIconsWithResponse request returning *ListIconsResponse
func (c *ClientWithResponses) ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error) {
	rsp, err := c.ListIcons(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListIconsResponse(rsp)
}

// ShowRegionByIdWithResponse request returning *ShowRegionByIdResponse
func (c *ClientWithResponses) ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error) {
	rsp, err := c.ShowRegionById(ctx, regionId)
	if err != nil {
		return nil, err
	}
	return ParseShowRegionByIdResponse(rsp)
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// ShowZoneByIdWithResponse request returning *ShowZoneByIdResponse
func (c *ClientWithResponses) ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error) {
	rsp, err := c.ShowZoneById(ctx, zoneId)
	if err != nil {
		return nil, err
	}
	return ParseShowZoneByIdResponse(rsp)
}

// ListZonesWithResponse request returning *ListZonesResponse
func (c *ClientWithResponses) ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error) {
	rsp, err := c.ListZones(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListZonesResponse(rsp)
}

// ParseCreateIconsResponse parses an HTTP response from a CreateIconsWithResponse call
func ParseCreateIconsResponse(rsp *http.Response) (*CreateIconsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateIconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIconByIdResponse parses an HTTP response from a DeleteIconByIdWithResponse call
func ParseDeleteIconByIdResponse(rsp *http.Response) (*DeleteIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowIconByIdResponse parses an HTTP response from a ShowIconByIdWithResponse call
func ParseShowIconByIdResponse(rsp *http.Response) (*ShowIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateIconByIdResponse parses an HTTP response from a UpdateIconByIdWithResponse call
func ParseUpdateIconByIdResponse(rsp *http.Response) (*UpdateIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIconsResponse parses an HTTP response from a ListIconsWithResponse call
func ParseListIconsResponse(rsp *http.Response) (*ListIconsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListIconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowRegionByIdResponse parses an HTTP response from a ShowRegionByIdWithResponse call
func ParseShowRegionByIdResponse(rsp *http.Response) (*ShowRegionByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowRegionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowZoneByIdResponse parses an HTTP response from a ShowZoneByIdWithResponse call
func ParseShowZoneByIdResponse(rsp *http.Response) (*ShowZoneByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowZoneByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListZonesResponse parses an HTTP response from a ListZonesWithResponse call
func ParseListZonesResponse(rsp *http.Response) (*ListZonesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbXW/bONb+KwLfd+40kp00Oxjf7LpxijW2H0HSbIENgoKRjm02EqkhqaSO4fntC5Ki",
	"LVmULWUSw1nkJk1Eng8envM8/OoCRSzNGAUqBRosEAeRMSpA/3FFcS5njJNHiM84Z1x9jBiVQKX6FWdZ",
	"QiIsCaPhD8Go+iaiGaRY/fb/HCZogP4vXFsITasIh+djo3C5XPooBhFxkik9aFCxinw0AxwD1/58+/bt",
	"+zCXM6BSmYWqPTnPAA2QkJzQqVK89NEVhZ8ZRHK//lubnu3jF2r1KFaygwXKOMuAS2LiDerz94jF4BiP",
	"XzSnYupsJeL7BEuclBpvGUsAU9UqgJNK21pQSCxz4Yqgjzj8kRMOMRpcrw2stK1k/bLrZUdvfKuU3f6A",
	"SCp7w0gF6gJEnsgzeg8Jy6AeCyK+szvXWOpesTunnQ9fzy+B34Mj0P9kQn7GqTvM4/NhHHMQLUKy0lOW",
	"cvpCaHwBf+QgZN2bU5abfCzECJUwBa7kzn5GSW7SgUhIhdPh4gPmHM+1Mc5St7oxfYK6S8ZlF4ll4/i3",
	"z/iWMDSP6CurpnypqW0GGbuFEavR35JY45HSOmE8xdKY/Ns75CNG4csEDa4dvtRidqPURAZxqlEY3mOS",
	"4FuSEDl3BvuUA5YQD2XFiRhL+FUSnYr1jB7twrPxSPX7xGIyId10N5bRZVTMcq3lK56Kbil4dfFxdzFW",
	"IleOkw5AZXSF29bJwiVjxznjEaNGX2MR29ncGuVNNe9ZPK+NQ2tq5YUWr3uS4qk78I1z1XVGNjy2EKgN",
	"N3muIOADSaTBYxzHRNEATs5Lzkueg78xHOt0B8CymbdtLkynYuxBVyPLLYMspQhOkgIStrlSFlJY0T42",
	"63juSrtS9B3OWzj6lCeSXBRLwK4DqKC7Gscun8Q3jrNMeWTtXxI6TaC7A84lRRsXah5cZfFzVHlFTfcq",
	"r4vXPHnOWnb6YEPz5Bh0G3LV53bTbqz4NQdpDD9da4JNf3S/G2c1bGJKJV+dIRFtYiKcQXGvGS9gSlwr",
	"hFF5t7FoYvv6eqgxY1SDWSn/FRIou1UwbsELZf3NA90XPyy3enBw4F0LTgN8m377A3Bjrwrh5tteQdyY",
	"dHjRWKvrstqtt5bkxefmLH4KjFlbewGyjXlrCI9oFx/RECB3na/WZUDzVHXOBXDkIzHDSvrGsbv49+fT",
	"c85+zg9gC/8fRl2b1u67sV34PSIiS/D8C4/N/Di2w+WTja11verYYRc4FqM8Tefuc6TGkHcrq+rMbpNY",
	"9att20v7uyr3VAJYjlaVlgpfSq6sx96UAE8lKRP79luY7pseM5qgq6FC7DlI1Mbn4Ch0Y+IaCFT12h99",
	"KmtV8lRf9kqdymDNg0ZesPC3S2OtTvXHpnp6Cl0aK3shy8osOUMi2sREOIPiohl9Uh/lnMj5pVJg9N9i",
	"QaJhLmerCwqNyurrmmBmUmbmOoLQCbM3HTjShQgpJomqZxwlLI8DxbziH1P1NYj0sSfVCIA+YUIlJlSt",
	"1X2U86TQLAZhOCVylt+q/mGhpxglqt2BfJ0R4RHhYS+GCaG6nIU3Ydy7HP7r6mLonSpxb3g+FgHyUUIi",
	"KBK+8GOY4WgG3lHQq7gxCMOHh4cA69aA8WlYiIrw4/j07PPl2a9HQS+YyTTRoAU8FV8mCv5JBKWhKCUC",
	"3+UcBzgOfmQhnnKAFKgMVUSJTFTvmq/IR2oXY8bYC3pBX1lhGVCcETRAx0EvOEY+yrCc6ZkLiT3kZQYR",
	"q2EyHOZhT3fTmri+jhrHq1azQTTpUzoNeJZrrPq55rKaqQp09YfSreBRr/+sDmyAnuNG7czep1k/PMk8",
	"7N3jhKhvljnQu15vLzd873HsXZTN9pu0rQIX1u9SteTxXhz+wPgtiWOgxujJXox+AjljsfeZSW+YJOwB",
	"YmX9ZE9zNKYSOMWJZ9Z+3irmJ3uKeQE63hXF5mIiAYOTE5wnsk3CVK+uNTfkaYr53IEcUp/6XSNijpNU",
	"Z4094UL9HMdLAz4JmFvzqqsj/X3swqB10/v5ONbQxnEKUp8VXS9qsA8eiT028aT6LWJUVWphVhETGmhs",
	"XPON8Q5tYo7fFj9GaLm8qQFU77ABamVQ80T4Z1/PlKKI0vyrvs8BLi2NHRuRd40if/Z/+e29ma5ffhuF",
	"U6jKvytBS0uTJ0bk97Yms7wq/7uWPzp+ovzRcQmPWrl8YqbkpENgT0xgn6nqTTV6Y3fN+2gKjkXGmE6Y",
	"XnphT2QQkQmJPGetX87Yw1+rdA6SE7h/q/XXU+svzoOK/z+wnMavrtq2FE699LLcUXrmHs9ZbOumgy+3",
	"l9l3VG9aW+073kr9tdH6i6PLKaOThJgDpWIp8OI2P7LoDl4fnJmCa0Iwu2H4+0IDkdAbBud64iMR0sNJ",
	"4tmTiSqwqWbbsoFpz1a6lRNjc+RVgz8zjBr8vfgKonqG7EifIfX0AaNCcxP9VwEhnSHgVRVHLald9cH1",
	"ZUm4MP8Wm+rWa+7VfVN91W2aui8EjCO7lwLW4cNdezufDrxRciMlv/qF9KoabKFx+3KgVGodyMg+PHDR",
	"0brtJQip/njokCjJ9S5oBynZmXijpcOhpXUKu+vlkVEIF+pnV1rS16kuUlIN3SlJubCbkIyjh0tHjsv4",
	"NzL63yWjogZsaT2a2/lVYXWgIXOx7yIh2/ISFLT59OaQCKj+rmYH/Zjov5HP4ZCPTd1afZSeq+hkLj1U",
	"ub5RWSXss/LrxcZjEi0H1UcY5k3JmsqWIc5I8bUf9JGP7jEn+DYxWfpYPEmyz0mJ6GP9H/f6t8rZO/2X",
	"vLN/3aObUmhM76WmkWJci/LJqRpvNUe/2JI2D1nURlEBP8t5ZN4jVTZbO+UNozs1PBbx3iqvJqUkfbP8",
	"bwAAAP//LmY6Rss9AAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

