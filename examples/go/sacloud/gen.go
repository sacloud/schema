// Package sacloud provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package sacloud

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/pkg/errors"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// APIError defines model for APIError.
type APIError struct {
	ErrorCode string `json:"error_code"`
	ErrorMsg  string `json:"error_msg"`
	IsFatal   bool   `json:"is_fatal"`
	Serial    string `json:"serial"`
	Status    string `json:"status"`
}

// ActionResultEnvelope defines model for ActionResultEnvelope.
type ActionResultEnvelope struct {
	IsOk bool `json:"is_ok"`
}

// CDROM defines model for CDROM.
type CDROM struct {
	Availability string     `json:"Availability"`
	CreatedAt    time.Time  `json:"CreatedAt"`
	Description  string     `json:"Description"`
	DisplayOrder int        `json:"DisplayOrder"`
	ID           ID         `json:"ID"`
	Icon         *IconView  `json:"Icon,omitempty"`
	ModifiedAt   time.Time  `json:"ModifiedAt"`
	Name         string     `json:"Name"`
	Scope        Scope      `json:"Scope"`
	SizeMB       CDROMSizes `json:"SizeMB"`
	StorageClass string     `json:"StorageClass"`
	Tags         []string   `json:"Tags"`
}

// CDROMCreateRequest defines model for CDROMCreateRequest.
type CDROMCreateRequest struct {
	CDROM CDROMCreateRequestBody `json:"CDROM"`
}

// CDROMCreateRequestBody defines model for CDROMCreateRequestBody.
type CDROMCreateRequestBody struct {
	Description *string     `json:"Description,omitempty"`
	Icon        *IDEnvelope `json:"Icon,omitempty"`
	Name        string      `json:"Name"`
	SizeMB      CDROMSizes  `json:"SizeMB"`
	Tags        *[]string   `json:"Tags,omitempty"`
}

// CDROMCreateResponse defines model for CDROMCreateResponse.
type CDROMCreateResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/CDROMWrapper)
	CDROMWrapper `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/FTPServerDetail)
	FTPServerDetail `yaml:",inline"`
}

// CDROMFilter defines model for CDROMFilter.
type CDROMFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	Scope                *Scope                 `json:"Scope,omitempty"`
	TagsName             *[]string              `json:"Tags.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CDROMFindRequest defines model for CDROMFindRequest.
type CDROMFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *CDROMFilter           `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CDROMMultiResponse defines model for CDROMMultiResponse.
type CDROMMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/CDROMsWrapper)
	CDROMsWrapper `yaml:",inline"`
}

// CDROMSingleResponse defines model for CDROMSingleResponse.
type CDROMSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/CDROMWrapper)
	CDROMWrapper `yaml:",inline"`
}

// CDROMSizes defines model for CDROMSizes.
type CDROMSizes int

// CDROMUpdateRequest defines model for CDROMUpdateRequest.
type CDROMUpdateRequest struct {
	CDROM CDROMUpdateRequestBody `json:"CDROM"`
}

// CDROMUpdateRequestBody defines model for CDROMUpdateRequestBody.
type CDROMUpdateRequestBody struct {
	Description *string   `json:"Description,omitempty"`
	Name        *string   `json:"Name,omitempty"`
	Tags        *[]string `json:"Tags,omitempty"`
}

// CDROMWrapper defines model for CDROMWrapper.
type CDROMWrapper struct {
	CDROM CDROM `json:"CDROM"`
}

// CDROMs defines model for CDROMs.
type CDROMs []struct {
	// Embedded struct due to allOf(#/components/schemas/CDROM)
	CDROM `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// CDROMsWrapper defines model for CDROMsWrapper.
type CDROMsWrapper struct {
	CDROMs CDROMs `json:"CDROMs"`
}

// FTPServerBody defines model for FTPServerBody.
type FTPServerBody struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// FTPServerDetail defines model for FTPServerDetail.
type FTPServerDetail struct {
	FTPServer FTPServerDetailBody `json:"FTPServer"`
}

// FTPServerDetailBody defines model for FTPServerDetailBody.
type FTPServerDetailBody struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
	Password  string `json:"Password"`
	User      string `json:"User"`
}

// FindRequest defines model for FindRequest.
type FindRequest struct {
	Count   *int      `json:"Count,omitempty"`
	Exclude *[]string `json:"Exclude,omitempty"`
	From    *int      `json:"From,omitempty"`
	Include *[]string `json:"Include,omitempty"`
	Sort    *[]string `json:"Sort,omitempty"`
}

// FindResultEnvelope defines model for FindResultEnvelope.
type FindResultEnvelope struct {
	Count int  `json:"Count"`
	From  int  `json:"From"`
	Total int  `json:"Total"`
	IsOk  bool `json:"is_ok"`
}

// ID defines model for ID.
type ID interface{}

// IDEnvelope defines model for IDEnvelope.
type IDEnvelope struct {
	ID *ID `json:"ID,omitempty"`
}

// Icon defines model for Icon.
type Icon struct {
	Availability string    `json:"Availability"`
	CreatedAt    time.Time `json:"CreatedAt"`
	ID           ID        `json:"ID"`
	ModifiedAt   time.Time `json:"ModifiedAt"`
	Name         string    `json:"Name"`
	Scope        string    `json:"Scope"`
	Tags         []string  `json:"Tags"`
	URL          string    `json:"URL"`
}

// IconCreateRequest defines model for IconCreateRequest.
type IconCreateRequest struct {
	Icon IconCreateRequestBody `json:"Icon"`
}

// IconCreateRequestBody defines model for IconCreateRequestBody.
type IconCreateRequestBody struct {
	Image string    `json:"Image"`
	Name  string    `json:"Name"`
	Tags  *[]string `json:"Tags,omitempty"`
}

// IconFindFilter defines model for IconFindFilter.
type IconFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	Scope                *Scope                 `json:"Scope,omitempty"`
	TagsName             *[]string              `json:"Tags.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconFindRequest defines model for IconFindRequest.
type IconFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *IconFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconMultiResponse defines model for IconMultiResponse.
type IconMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconsWrapper)
	IconsWrapper `yaml:",inline"`
}

// IconSingleResponse defines model for IconSingleResponse.
type IconSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconWrapper)
	IconWrapper `yaml:",inline"`
}

// IconUpdateRequest defines model for IconUpdateRequest.
type IconUpdateRequest struct {
	Icon IconUpdateRequestBody `json:"Icon"`
}

// IconUpdateRequestBody defines model for IconUpdateRequestBody.
type IconUpdateRequestBody struct {
	Name *string   `json:"Name,omitempty"`
	Tags *[]string `json:"Tags,omitempty"`
}

// IconView defines model for IconView.
type IconView struct {
	ID    ID     `json:"ID"`
	Name  string `json:"Name"`
	Scope string `json:"Scope"`
	URL   string `json:"URL"`
}

// IconWrapper defines model for IconWrapper.
type IconWrapper struct {
	Icon Icon `json:"Icon"`
}

// Icons defines model for Icons.
type Icons []struct {
	// Embedded struct due to allOf(#/components/schemas/Icon)
	Icon `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// IconsWrapper defines model for IconsWrapper.
type IconsWrapper struct {
	Icons Icons `json:"Icons"`
}

// Region defines model for Region.
type Region struct {
	Description string   `json:"Description"`
	ID          int      `json:"ID"`
	Name        string   `json:"Name"`
	NameServers []string `json:"NameServers"`
}

// RegionFindFilter defines model for RegionFindFilter.
type RegionFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionFindRequest defines model for RegionFindRequest.
type RegionFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *RegionFindFilter      `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionMultiResponse defines model for RegionMultiResponse.
type RegionMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionsWrapper)
	RegionsWrapper `yaml:",inline"`
}

// RegionSingleResponse defines model for RegionSingleResponse.
type RegionSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionWrapper)
	RegionWrapper `yaml:",inline"`
}

// RegionWrapper defines model for RegionWrapper.
type RegionWrapper struct {
	Region Region `json:"Region"`
}

// Regions defines model for Regions.
type Regions []struct {
	// Embedded struct due to allOf(#/components/schemas/Region)
	Region `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// RegionsWrapper defines model for RegionsWrapper.
type RegionsWrapper struct {
	Regions Regions `json:"Regions"`
}

// Scope defines model for Scope.
type Scope string

// List of Scope
const (
	Scope_shared Scope = "shared"
	Scope_user   Scope = "user"
)

// VNCProxy defines model for VNCProxy.
type VNCProxy struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// Zone defines model for Zone.
type Zone struct {
	CreatedAt    time.Time     `json:"CreatedAt"`
	Description  string        `json:"Description"`
	DisplayOrder int           `json:"DisplayOrder"`
	FTPServer    FTPServerBody `json:"FTPServer"`
	ID           ID            `json:"ID"`
	IsDummy      bool          `json:"IsDummy"`
	Name         string        `json:"Name"`
	Region       Region        `json:"Region"`
	VNCProxy     VNCProxy      `json:"VNCProxy"`
}

// ZoneFindFilter defines model for ZoneFindFilter.
type ZoneFindFilter struct {
	ID                   *[]string              `json:"ID,omitempty"`
	Name                 *[]string              `json:"Name,omitempty"`
	RegionID             *[]string              `json:"Region.ID,omitempty"`
	RegionName           *[]string              `json:"Region.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneFindRequest defines model for ZoneFindRequest.
type ZoneFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *ZoneFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneMultiResponse defines model for ZoneMultiResponse.
type ZoneMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZonesWrapper)
	ZonesWrapper `yaml:",inline"`
}

// ZoneSingleResponse defines model for ZoneSingleResponse.
type ZoneSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZoneWrapper)
	ZoneWrapper `yaml:",inline"`
}

// ZoneWrapper defines model for ZoneWrapper.
type ZoneWrapper struct {
	Zone Zone `json:"Zone"`
}

// Zones defines model for Zones.
type Zones []struct {
	// Embedded struct due to allOf(#/components/schemas/Zone)
	Zone `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// ZonesWrapper defines model for ZonesWrapper.
type ZonesWrapper struct {
	Zones Zones `json:"Zones"`
}

// BadRequest defines model for BadRequest.
type BadRequest APIError

// Conflict defines model for Conflict.
type Conflict APIError

// Forbidden defines model for Forbidden.
type Forbidden APIError

// InternalServerError defines model for InternalServerError.
type InternalServerError APIError

// Locked defines model for Locked.
type Locked APIError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed APIError

// NotFound defines model for NotFound.
type NotFound APIError

// ServiceUnavailable defines model for ServiceUnavailable.
type ServiceUnavailable APIError

// Unauthorized defines model for Unauthorized.
type Unauthorized APIError

// UnexpectedError defines model for UnexpectedError.
type UnexpectedError APIError

// CreateCDROMJSONBody defines parameters for CreateCDROM.
type CreateCDROMJSONBody CDROMCreateRequest

// UpdateCDROMByIdJSONBody defines parameters for UpdateCDROMById.
type UpdateCDROMByIdJSONBody CDROMUpdateRequest

// CreateIconJSONBody defines parameters for CreateIcon.
type CreateIconJSONBody IconCreateRequest

// UpdateIconByIdJSONBody defines parameters for UpdateIconById.
type UpdateIconByIdJSONBody IconUpdateRequest

// CreateCDROMJSONRequestBody defines body for CreateCDROM for application/json ContentType.
type CreateCDROMJSONRequestBody CreateCDROMJSONBody

// UpdateCDROMByIdJSONRequestBody defines body for UpdateCDROMById for application/json ContentType.
type UpdateCDROMByIdJSONRequestBody UpdateCDROMByIdJSONBody

// CreateIconJSONRequestBody defines body for CreateIcon for application/json ContentType.
type CreateIconJSONRequestBody CreateIconJSONBody

// UpdateIconByIdJSONRequestBody defines body for UpdateIconById for application/json ContentType.
type UpdateIconByIdJSONRequestBody UpdateIconByIdJSONBody

// Getter for additional properties for CDROMFilter. Returns the specified
// element and whether it was found
func (a CDROMFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CDROMFilter
func (a *CDROMFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CDROMFilter to handle AdditionalProperties
func (a *CDROMFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Scope"]; found {
		err = json.Unmarshal(raw, &a.Scope)
		if err != nil {
			return errors.Wrap(err, "error reading 'Scope'")
		}
		delete(object, "Scope")
	}

	if raw, found := object["Tags.Name"]; found {
		err = json.Unmarshal(raw, &a.TagsName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Tags.Name'")
		}
		delete(object, "Tags.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CDROMFilter to handle AdditionalProperties
func (a CDROMFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.Scope != nil {
		object["Scope"], err = json.Marshal(a.Scope)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Scope'"))
		}
	}

	if a.TagsName != nil {
		object["Tags.Name"], err = json.Marshal(a.TagsName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Tags.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CDROMFindRequest. Returns the specified
// element and whether it was found
func (a CDROMFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CDROMFindRequest
func (a *CDROMFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CDROMFindRequest to handle AdditionalProperties
func (a *CDROMFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CDROMFindRequest to handle AdditionalProperties
func (a CDROMFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IconFindFilter. Returns the specified
// element and whether it was found
func (a IconFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindFilter
func (a *IconFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a *IconFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Scope"]; found {
		err = json.Unmarshal(raw, &a.Scope)
		if err != nil {
			return errors.Wrap(err, "error reading 'Scope'")
		}
		delete(object, "Scope")
	}

	if raw, found := object["Tags.Name"]; found {
		err = json.Unmarshal(raw, &a.TagsName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Tags.Name'")
		}
		delete(object, "Tags.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a IconFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.Scope != nil {
		object["Scope"], err = json.Marshal(a.Scope)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Scope'"))
		}
	}

	if a.TagsName != nil {
		object["Tags.Name"], err = json.Marshal(a.TagsName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Tags.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IconFindRequest. Returns the specified
// element and whether it was found
func (a IconFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindRequest
func (a *IconFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a *IconFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a IconFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindFilter. Returns the specified
// element and whether it was found
func (a RegionFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindFilter
func (a *RegionFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a *RegionFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a RegionFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindRequest. Returns the specified
// element and whether it was found
func (a RegionFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindRequest
func (a *RegionFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a *RegionFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a RegionFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindFilter. Returns the specified
// element and whether it was found
func (a ZoneFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindFilter
func (a *ZoneFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a *ZoneFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ID"]; found {
		err = json.Unmarshal(raw, &a.ID)
		if err != nil {
			return errors.Wrap(err, "error reading 'ID'")
		}
		delete(object, "ID")
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Region.ID"]; found {
		err = json.Unmarshal(raw, &a.RegionID)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.ID'")
		}
		delete(object, "Region.ID")
	}

	if raw, found := object["Region.Name"]; found {
		err = json.Unmarshal(raw, &a.RegionName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.Name'")
		}
		delete(object, "Region.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a ZoneFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ID != nil {
		object["ID"], err = json.Marshal(a.ID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'ID'"))
		}
	}

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.RegionID != nil {
		object["Region.ID"], err = json.Marshal(a.RegionID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.ID'"))
		}
	}

	if a.RegionName != nil {
		object["Region.Name"], err = json.Marshal(a.RegionName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindRequest. Returns the specified
// element and whether it was found
func (a ZoneFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindRequest
func (a *ZoneFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a *ZoneFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a ZoneFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateCDROM request  with any body
	CreateCDROMWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCDROM(ctx context.Context, body CreateCDROMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCDROMById request
	DeleteCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowCDROMById request
	ShowCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCDROMById request  with any body
	UpdateCDROMByIdWithBody(ctx context.Context, cdromId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCDROMById(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloseFTP request
	CloseFTP(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenFTP request
	OpenFTP(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCDROMs request
	ListCDROMs(ctx context.Context, params CDROMFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIcon request  with any body
	CreateIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIcon(ctx context.Context, body CreateIconJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIconById request
	DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowIconById request
	ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIcons request
	ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowRegionById request
	ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegions request
	ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowZoneById request
	ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListZones request
	ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateCDROMWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCDROMRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCDROM(ctx context.Context, body CreateCDROMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCDROMRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCDROMByIdRequest(c.Server, cdromId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowCDROMByIdRequest(c.Server, cdromId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCDROMByIdWithBody(ctx context.Context, cdromId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCDROMByIdRequestWithBody(c.Server, cdromId, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCDROMById(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCDROMByIdRequest(c.Server, cdromId, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseFTP(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseFTPRequest(c.Server, cdromId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenFTP(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenFTPRequest(c.Server, cdromId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCDROMs(ctx context.Context, params CDROMFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCDROMsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIcon(ctx context.Context, body CreateIconJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequestWithBody(c.Server, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequest(c.Server, iconId, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIconsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRegionByIdRequest(c.Server, regionId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowZoneByIdRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateCDROMRequest calls the generic CreateCDROM builder with application/json body
func NewCreateCDROMRequest(server string, body CreateCDROMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCDROMRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCDROMRequestWithBody generates requests for CreateCDROM with any type of body
func NewCreateCDROMRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCDROMByIdRequest generates requests for DeleteCDROMById
func NewDeleteCDROMByIdRequest(server string, cdromId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowCDROMByIdRequest generates requests for ShowCDROMById
func NewShowCDROMByIdRequest(server string, cdromId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCDROMByIdRequest calls the generic UpdateCDROMById builder with application/json body
func NewUpdateCDROMByIdRequest(server string, cdromId ID, body UpdateCDROMByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCDROMByIdRequestWithBody(server, cdromId, "application/json", bodyReader)
}

// NewUpdateCDROMByIdRequestWithBody generates requests for UpdateCDROMById with any type of body
func NewUpdateCDROMByIdRequestWithBody(server string, cdromId ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCloseFTPRequest generates requests for CloseFTP
func NewCloseFTPRequest(server string, cdromId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s/ftp", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOpenFTPRequest generates requests for OpenFTP
func NewOpenFTPRequest(server string, cdromId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s/ftp", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCDROMsRequest generates requests for ListCDROMs
func NewListCDROMsRequest(server string, params CDROMFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIconRequest calls the generic CreateIcon builder with application/json body
func NewCreateIconRequest(server string, body CreateIconJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIconRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIconRequestWithBody generates requests for CreateIcon with any type of body
func NewCreateIconRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIconByIdRequest generates requests for DeleteIconById
func NewDeleteIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowIconByIdRequest generates requests for ShowIconById
func NewShowIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIconByIdRequest calls the generic UpdateIconById builder with application/json body
func NewUpdateIconByIdRequest(server string, iconId ID, body UpdateIconByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIconByIdRequestWithBody(server, iconId, "application/json", bodyReader)
}

// NewUpdateIconByIdRequestWithBody generates requests for UpdateIconById with any type of body
func NewUpdateIconByIdRequestWithBody(server string, iconId ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIconsRequest generates requests for ListIcons
func NewListIconsRequest(server string, params IconFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowRegionByIdRequest generates requests for ShowRegionById
func NewShowRegionByIdRequest(server string, regionId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "regionId", regionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string, params RegionFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowZoneByIdRequest generates requests for ShowZoneById
func NewShowZoneByIdRequest(server string, zoneId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "zoneId", zoneId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListZonesRequest generates requests for ListZones
func NewListZonesRequest(server string, params ZoneFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	req = req.WithContext(ctx)
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateCDROM request  with any body
	CreateCDROMWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateCDROMResponse, error)

	CreateCDROMWithResponse(ctx context.Context, body CreateCDROMJSONRequestBody) (*CreateCDROMResponse, error)

	// DeleteCDROMById request
	DeleteCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*DeleteCDROMByIdResponse, error)

	// ShowCDROMById request
	ShowCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*ShowCDROMByIdResponse, error)

	// UpdateCDROMById request  with any body
	UpdateCDROMByIdWithBodyWithResponse(ctx context.Context, cdromId ID, contentType string, body io.Reader) (*UpdateCDROMByIdResponse, error)

	UpdateCDROMByIdWithResponse(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody) (*UpdateCDROMByIdResponse, error)

	// CloseFTP request
	CloseFTPWithResponse(ctx context.Context, cdromId ID) (*CloseFTPResponse, error)

	// OpenFTP request
	OpenFTPWithResponse(ctx context.Context, cdromId ID) (*OpenFTPResponse, error)

	// ListCDROMs request
	ListCDROMsWithResponse(ctx context.Context, params CDROMFindRequest) (*ListCDROMsResponse, error)

	// CreateIcon request  with any body
	CreateIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconResponse, error)

	CreateIconWithResponse(ctx context.Context, body CreateIconJSONRequestBody) (*CreateIconResponse, error)

	// DeleteIconById request
	DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error)

	// ShowIconById request
	ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error)

	UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error)

	// ListIcons request
	ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error)

	// ShowRegionById request
	ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error)

	// ListRegions request
	ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error)

	// ShowZoneById request
	ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error)

	// ListZones request
	ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error)
}

type CreateCDROMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CDROMCreateResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r CreateCDROMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCDROMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCDROMByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r DeleteCDROMByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCDROMByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowCDROMByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowCDROMByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowCDROMByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCDROMByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateCDROMByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCDROMByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloseFTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionResultEnvelope
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r CloseFTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloseFTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenFTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
		ActionResultEnvelope `yaml:",inline"`
		// Embedded struct due to allOf(#/components/schemas/FTPServerDetail)
		FTPServerDetail `yaml:",inline"`
	}
	JSON400     *APIError
	JSON401     *APIError
	JSON403     *APIError
	JSON404     *APIError
	JSON405     *APIError
	JSON409     *APIError
	JSON423     *APIError
	JSON500     *APIError
	JSON503     *APIError
	JSONDefault *APIError
}

// Status returns HTTPResponse.Status
func (r OpenFTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenFTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCDROMsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListCDROMsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCDROMsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r CreateIconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r DeleteIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListIconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowRegionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowRegionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowRegionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowZoneByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowZoneByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowZoneByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateCDROMWithBodyWithResponse request with arbitrary body returning *CreateCDROMResponse
func (c *ClientWithResponses) CreateCDROMWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateCDROMResponse, error) {
	rsp, err := c.CreateCDROMWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateCDROMResponse(rsp)
}

func (c *ClientWithResponses) CreateCDROMWithResponse(ctx context.Context, body CreateCDROMJSONRequestBody) (*CreateCDROMResponse, error) {
	rsp, err := c.CreateCDROM(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateCDROMResponse(rsp)
}

// DeleteCDROMByIdWithResponse request returning *DeleteCDROMByIdResponse
func (c *ClientWithResponses) DeleteCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*DeleteCDROMByIdResponse, error) {
	rsp, err := c.DeleteCDROMById(ctx, cdromId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCDROMByIdResponse(rsp)
}

// ShowCDROMByIdWithResponse request returning *ShowCDROMByIdResponse
func (c *ClientWithResponses) ShowCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*ShowCDROMByIdResponse, error) {
	rsp, err := c.ShowCDROMById(ctx, cdromId)
	if err != nil {
		return nil, err
	}
	return ParseShowCDROMByIdResponse(rsp)
}

// UpdateCDROMByIdWithBodyWithResponse request with arbitrary body returning *UpdateCDROMByIdResponse
func (c *ClientWithResponses) UpdateCDROMByIdWithBodyWithResponse(ctx context.Context, cdromId ID, contentType string, body io.Reader) (*UpdateCDROMByIdResponse, error) {
	rsp, err := c.UpdateCDROMByIdWithBody(ctx, cdromId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCDROMByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateCDROMByIdWithResponse(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody) (*UpdateCDROMByIdResponse, error) {
	rsp, err := c.UpdateCDROMById(ctx, cdromId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCDROMByIdResponse(rsp)
}

// CloseFTPWithResponse request returning *CloseFTPResponse
func (c *ClientWithResponses) CloseFTPWithResponse(ctx context.Context, cdromId ID) (*CloseFTPResponse, error) {
	rsp, err := c.CloseFTP(ctx, cdromId)
	if err != nil {
		return nil, err
	}
	return ParseCloseFTPResponse(rsp)
}

// OpenFTPWithResponse request returning *OpenFTPResponse
func (c *ClientWithResponses) OpenFTPWithResponse(ctx context.Context, cdromId ID) (*OpenFTPResponse, error) {
	rsp, err := c.OpenFTP(ctx, cdromId)
	if err != nil {
		return nil, err
	}
	return ParseOpenFTPResponse(rsp)
}

// ListCDROMsWithResponse request returning *ListCDROMsResponse
func (c *ClientWithResponses) ListCDROMsWithResponse(ctx context.Context, params CDROMFindRequest) (*ListCDROMsResponse, error) {
	rsp, err := c.ListCDROMs(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListCDROMsResponse(rsp)
}

// CreateIconWithBodyWithResponse request with arbitrary body returning *CreateIconResponse
func (c *ClientWithResponses) CreateIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconResponse, error) {
	rsp, err := c.CreateIconWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconResponse(rsp)
}

func (c *ClientWithResponses) CreateIconWithResponse(ctx context.Context, body CreateIconJSONRequestBody) (*CreateIconResponse, error) {
	rsp, err := c.CreateIcon(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconResponse(rsp)
}

// DeleteIconByIdWithResponse request returning *DeleteIconByIdResponse
func (c *ClientWithResponses) DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error) {
	rsp, err := c.DeleteIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIconByIdResponse(rsp)
}

// ShowIconByIdWithResponse request returning *ShowIconByIdResponse
func (c *ClientWithResponses) ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error) {
	rsp, err := c.ShowIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseShowIconByIdResponse(rsp)
}

// UpdateIconByIdWithBodyWithResponse request with arbitrary body returning *UpdateIconByIdResponse
func (c *ClientWithResponses) UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconByIdWithBody(ctx, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconById(ctx, iconId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

// ListIconsWithResponse request returning *ListIconsResponse
func (c *ClientWithResponses) ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error) {
	rsp, err := c.ListIcons(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListIconsResponse(rsp)
}

// ShowRegionByIdWithResponse request returning *ShowRegionByIdResponse
func (c *ClientWithResponses) ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error) {
	rsp, err := c.ShowRegionById(ctx, regionId)
	if err != nil {
		return nil, err
	}
	return ParseShowRegionByIdResponse(rsp)
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// ShowZoneByIdWithResponse request returning *ShowZoneByIdResponse
func (c *ClientWithResponses) ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error) {
	rsp, err := c.ShowZoneById(ctx, zoneId)
	if err != nil {
		return nil, err
	}
	return ParseShowZoneByIdResponse(rsp)
}

// ListZonesWithResponse request returning *ListZonesResponse
func (c *ClientWithResponses) ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error) {
	rsp, err := c.ListZones(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListZonesResponse(rsp)
}

// ParseCreateCDROMResponse parses an HTTP response from a CreateCDROMWithResponse call
func ParseCreateCDROMResponse(rsp *http.Response) (*CreateCDROMResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCDROMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CDROMCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCDROMByIdResponse parses an HTTP response from a DeleteCDROMByIdWithResponse call
func ParseDeleteCDROMByIdResponse(rsp *http.Response) (*DeleteCDROMByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCDROMByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowCDROMByIdResponse parses an HTTP response from a ShowCDROMByIdWithResponse call
func ParseShowCDROMByIdResponse(rsp *http.Response) (*ShowCDROMByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowCDROMByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCDROMByIdResponse parses an HTTP response from a UpdateCDROMByIdWithResponse call
func ParseUpdateCDROMByIdResponse(rsp *http.Response) (*UpdateCDROMByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateCDROMByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCloseFTPResponse parses an HTTP response from a CloseFTPWithResponse call
func ParseCloseFTPResponse(rsp *http.Response) (*CloseFTPResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CloseFTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionResultEnvelope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOpenFTPResponse parses an HTTP response from a OpenFTPWithResponse call
func ParseOpenFTPResponse(rsp *http.Response) (*OpenFTPResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &OpenFTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
			ActionResultEnvelope `yaml:",inline"`
			// Embedded struct due to allOf(#/components/schemas/FTPServerDetail)
			FTPServerDetail `yaml:",inline"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCDROMsResponse parses an HTTP response from a ListCDROMsWithResponse call
func ParseListCDROMsResponse(rsp *http.Response) (*ListCDROMsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCDROMsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIconResponse parses an HTTP response from a CreateIconWithResponse call
func ParseCreateIconResponse(rsp *http.Response) (*CreateIconResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateIconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIconByIdResponse parses an HTTP response from a DeleteIconByIdWithResponse call
func ParseDeleteIconByIdResponse(rsp *http.Response) (*DeleteIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowIconByIdResponse parses an HTTP response from a ShowIconByIdWithResponse call
func ParseShowIconByIdResponse(rsp *http.Response) (*ShowIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateIconByIdResponse parses an HTTP response from a UpdateIconByIdWithResponse call
func ParseUpdateIconByIdResponse(rsp *http.Response) (*UpdateIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIconsResponse parses an HTTP response from a ListIconsWithResponse call
func ParseListIconsResponse(rsp *http.Response) (*ListIconsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListIconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowRegionByIdResponse parses an HTTP response from a ShowRegionByIdWithResponse call
func ParseShowRegionByIdResponse(rsp *http.Response) (*ShowRegionByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowRegionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowZoneByIdResponse parses an HTTP response from a ShowZoneByIdWithResponse call
func ParseShowZoneByIdResponse(rsp *http.Response) (*ShowZoneByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowZoneByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListZonesResponse parses an HTTP response from a ListZonesWithResponse call
func ParseListZonesResponse(rsp *http.Response) (*ListZonesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xcaW/bPBL+KwJ3P6qWk6YLrL/sunGCNbY5kOMtsIFRMBJts5FFvSSVNDH03xc8JEsW",
	"dTmx6uT1lzYRjxkO55mHwyNL4JJFSAIUcAYGS0ARC0nAkPzlK/Su0J8RYlz85pKAo0D+CMPQxy7kmATO",
	"T0YC8Y25c7SA4qe/UzQFA/A3Z9W1o0qZM7wcn1BKKIjj2AYeYi7FoegHDIQ4K5EX2+CYBFMfu93IToXF",
	"Njgl9B57Hgo6kbySFttgHHBEA+hfI/qIqGrThRKJXEsJtnRFG3wj7gPyOtFBi4ptcIb4nHjnhA99nzx1",
	"JF4Jtc4JtxKxsQ3OCT8lUdCNCkK2khbbQMwEdtFtAB8h9uG9jzrRQYu1snJjG9wGMOJzQvFLR9ORE2iD",
	"OYIeojIqff/+/ccw4nMUcCEW5eXx5xCBAWCc4mAmOpbKo18hcjnyukPUSmYCptjW3cpRpG0HSxBSEiLK",
	"sYq6SHz+4RIPGcZj6+IFmxlLMfsxhRz6mcJ7QnwEZXhhiOJc2aoh45BHzGRBG1D0Z4SpmPi7lYC0t7St",
	"nVU9q+jETjol9z+RCrJDVxjqCrHI5yfBI/JJiIq2wOwHeTCNpagVeTDKOR5dXZwVOx4q58Y+5s9GexxT",
	"BDnyhtJFpoQuIAcD4EGOPnG8EOMrNBllHcDQ5Qiz0IfPF9RDNFMBBxzNkIy241Gdy41Hsp6rRFTWdEnw",
	"B0ZPMqASD09xu9Gcw4XZAa9dPVVV0lUlURu/oLOvddXlLImqTLbhhMIZOvYhY0YVbuBMuQdHC3MN/QFS",
	"Cp8L3jIeAT2+ZDSpnvlZ1JLsvLtknWNtVnOmXhtIqXeq3jIrrbyrph5ca8BcR1+JVxy56quZJrKDgjZ1",
	"Tt7INUcp4isdbQPXeaVnJE6hJNfaSa2VJYn4/sUUDO5qCMMU9GK7wQC/UxiGMkhUVz69uVRLuBHiEPsg",
	"niQ6n2Kfq7gDPQ8LPaB/mZlaTiNkr012MjVNrdk2OIjZ6rUVEpfNyikOsvlKsynJNhLGbW6clUFrZ09X",
	"NaieTs9Z5HPc3qOU+u39iaUOlWpwjYOZ/3ucOqPDi14EBdECDO6+HBz27YP+4VF/hcUMX8o2t6H3NuEz",
	"19Em4bPYQevwWRoMNwhsZiUTo7/CUG3tkle8mVdpQfa6luPAQ79Mq6d1jpf1JkbArQetPCLMhmGNLMPM",
	"pjGTfxqrza7yH8J4qTuML4eeRxFrsGJP+8m2qtRHc0dBo7RCnS3WejJiadVZA13e2EI2uISMPRHqGQtv",
	"WW6B3sauunFGgHF0eaZaczcSqcS0GO9Ofrl+5LWk5FNKFiXpRrBBd9eE8tcGIgNrtTFD+YhuSD73zRQ1",
	"TSWVXC0k6dGuyDBV0pYmVTjg/zgCNiAB0mGuoEvBZhPZTbktmuWFJksny/HtZ79Nc9ft5KKv5ksb3F59",
	"qwd9RSIos8pc+reWYupcUsiZlExVTSrYNO+vTwRlT420MIfe8QLO0NZXMIbUTAku01wElg+d6CSD3Lk8",
	"Z836JamOqNVdpiOk5RMd8aXTPEcILGhQk7E0RXl9vlKJ8gbZylazkXSDckO624gWGgV50/5gVdQuzRya",
	"zmS7idsknVJSOsmmcqgzmoQ1sQkzGsWcuVyhGTatc2o3K0fmtWKpY4kClZe8hsryW8xZb8v2Xz7Qrlgu",
	"rtRg5yioYJwSElL1uqMhJS9PROpbp1SkRBq0KMXqClb1/RacXH8u9+JNwlgiq5NAtjZvJeZhzezDSgxk",
	"xnlKYHofFERqV4HNoWg9MeRIf5wfX1Lyaxc2kv5HAlNC/ztOVNtvWamFVIuzWDaKFotn84F7qdnbQSs/",
	"u1Ut0nqFbY3skWWOf9YOMFcWy1OT1iWjymrsZU6wKVEp2zdPxtqnb2o0vbaCdLO3INLEPjtHo2sTV0Ki",
	"olZ3FCqk5QlUfOmUPoXAggal3JCEwLoeCziVH8vwtAllKimdEGZulowmYU1swoxGMVGNvNLkRhTz52vR",
	"ger/HjLsDiM+T29yyagsvq5IZs55qO5t4WBKkithUF03RQt5/gEYdH0SeT3BvuzfM/G158pt4UBGAHAG",
	"ccAhDsR63QYR9XXPbOA4M8zn0b2o7+h+9ChB4bLYzRwzCzMLWh6a4kDCmVlTQq3r4X9vr4bWsWhuDS/H",
	"rAds4GMXaYfXegxD6M6Rddjr59QYOM7T01MPytIeoTNHN2XOt/Hxyfn1yafDXr835wtfBi1EF+xiqq8A",
	"ZoYiOmHwIaKwB73ez9CBM4rQAgXcERbF3Be1C7oCG4hMRo2x3+v3DoQUEqIAhhgMwOdev/cZ2CCEfC5n",
	"znE9vbUfEhUS127pShKzoHU8+nR1cQZkZ1Re3Rt7abk6OlQelNnaeJMrf4YLO3HeW0XglR8yF6kP+wfb",
	"0UBHPsP9w5Pk9mGiiMWJBa1H6GPxLb1lfdTvl0lMh+BkLoLLJgf1TXL3N2Wjz/WNcnehj/pf6lsUrgrH",
	"NvjSZEimm9aybQM1DVdzpf2nMPJ5E9Pkr6PKMBYtFpA+G32cy822OyDBwcBE1FdIcZbyv7EXK6z4SF2H",
	"zbvCSH5PUJFHTKbs6/PYk2CkcIG43OG4WxYCFbKwZ5GpxefIksKFX2nJIpaCgYTzKkRqDcE6RuyG/i5P",
	"tiYFQPXfFlBrS4kPCqij+hbphffXIPCo/8/6htknF0eHDQazeiDwvhGuMFeBbxvMkIH9xsGUyEUBtFiI",
	"XDzFbhkRXs/J02tBTRGnGD3uYf3RYP2+0VOJAgOUwsgAJXX2ZabETNk7QM+Wlrj5I8pGS9w9dPeM/E5j",
	"ivL2dituZ8rDqlX3sU8Ysk5vLi2XBAFy9W7rWsIqKp3eXP4V193mXbg9zPcw31pqbYZk00XDRYiCOkCL",
	"Opvj+R0sube4w254u7SPBvtosK1okMC5ku//tZQ4ZnKDzZiVf8OMW9D3y1JxUa4fgRSCwtutlnOHgupU",
	"oxA/1EgK4WP7WXj+nNAA6mFgyUMkERCVGdl+b3oHIVP0dSNycPLooPoQR1YzH+GMVdE20tviNfuOD3AM",
	"d5D35zcf8PxGu3eCEKxur6YAcZbi30ZHN2MTUFZF7XephOS6/FFpt7vp418HRvvl4g6d2ozNqG5xZGNE",
	"8/WcPL0Oy9W54x7N+8OaHTmsKUVQxUmNETOrop1HzXaWsb/1kGaP2D3//oYzmnH1qrrFfo16TmbarklK",
	"trFbs/6Ad5c2a4qvc2v2apT191noDu/UJL5sAgyVrxmcpfpfp6KN17Hpg5DiSlYVtWdlpUg9LycK7+56",
	"1vi+b8+PH3NFmyIhARlNnvZlYNaCmZKXgSZuWpVtg52Kr3t3iZ9MD3drGCqZiT1H7TBHrXzaDKAXEiBn",
	"Kf5ty1Hy8ZOJoURBe34SKtSzk1J0d7nJ8HRuz0wfk5m0/yewelHv6FJQteAk9QTPxEhJyTb4aP2R7C6x",
	"UfEFbA0XKevvmWiHmSjx5QJgMi9NpXdn3pjeTYSbseSvwtwt196BynYo/35SPQdd8VrswBDrrwe9A2CD",
	"R0ixGKV02xf9mjj5axCYHUD5NwkP7oWyD/I3/pD89ggmGdOo2rHkFD2uZe5KmRhw4aabArl6hKpO+wUR",
	"kIi66iJXZoe0tr3IQY2taUr8le3V+sDYw4uesMr2YlYzrSfx/wMAAP//gWppxfZmAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

