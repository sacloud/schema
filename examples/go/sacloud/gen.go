// Package sacloud provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package sacloud

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/pkg/errors"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// APIError defines model for APIError.
type APIError struct {
	ErrorCode string `json:"error_code"`
	ErrorMsg  string `json:"error_msg"`
	IsFatal   bool   `json:"is_fatal"`
	Serial    string `json:"serial"`
	Status    string `json:"status"`
}

// ActionResultEnvelope defines model for ActionResultEnvelope.
type ActionResultEnvelope struct {
	IsOk bool `json:"is_ok"`
}

// CDROM defines model for CDROM.
type CDROM struct {
	Availability string     `json:"Availability"`
	CreatedAt    time.Time  `json:"CreatedAt"`
	Description  string     `json:"Description"`
	DisplayOrder int        `json:"DisplayOrder"`
	ID           ID         `json:"ID"`
	Icon         *IconView  `json:"Icon,omitempty"`
	ModifiedAt   time.Time  `json:"ModifiedAt"`
	Name         string     `json:"Name"`
	Scope        Scope      `json:"Scope"`
	SizeMB       CDROMSizes `json:"SizeMB"`
	StorageClass string     `json:"StorageClass"`
	Tags         []string   `json:"Tags"`
}

// CDROMCreateRequest defines model for CDROMCreateRequest.
type CDROMCreateRequest struct {
	CDROM CDROMCreateRequestBody `json:"CDROM"`
}

// CDROMCreateRequestBody defines model for CDROMCreateRequestBody.
type CDROMCreateRequestBody struct {
	Description *string     `json:"Description,omitempty"`
	Icon        *IDEnvelope `json:"Icon,omitempty"`
	Name        string      `json:"Name"`
	SizeMB      CDROMSizes  `json:"SizeMB"`
	Tags        *[]string   `json:"Tags,omitempty"`
}

// CDROMCreateResponse defines model for CDROMCreateResponse.
type CDROMCreateResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/CDROMWrapper)
	CDROMWrapper `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/FTPServerDetail)
	FTPServerDetail `yaml:",inline"`
}

// CDROMFilter defines model for CDROMFilter.
type CDROMFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	Scope                *Scope                 `json:"Scope,omitempty"`
	TagsName             *[]string              `json:"Tags.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CDROMFindRequest defines model for CDROMFindRequest.
type CDROMFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *CDROMFilter           `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CDROMMultiResponse defines model for CDROMMultiResponse.
type CDROMMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/CDROMsWrapper)
	CDROMsWrapper `yaml:",inline"`
}

// CDROMSingleResponse defines model for CDROMSingleResponse.
type CDROMSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/CDROMWrapper)
	CDROMWrapper `yaml:",inline"`
}

// CDROMSizes defines model for CDROMSizes.
type CDROMSizes int

// CDROMUpdateRequest defines model for CDROMUpdateRequest.
type CDROMUpdateRequest struct {
	CDROM CDROMUpdateRequestBody `json:"CDROM"`
}

// CDROMUpdateRequestBody defines model for CDROMUpdateRequestBody.
type CDROMUpdateRequestBody struct {
	Description *string   `json:"Description,omitempty"`
	Name        *string   `json:"Name,omitempty"`
	Tags        *[]string `json:"Tags,omitempty"`
}

// CDROMWrapper defines model for CDROMWrapper.
type CDROMWrapper struct {
	CDROM CDROM `json:"CDROM"`
}

// CDROMs defines model for CDROMs.
type CDROMs []struct {
	// Embedded struct due to allOf(#/components/schemas/CDROM)
	CDROM `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// CDROMsWrapper defines model for CDROMsWrapper.
type CDROMsWrapper struct {
	CDROMs CDROMs `json:"CDROMs"`
}

// FTPServer defines model for FTPServer.
type FTPServer struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// FTPServerDetail defines model for FTPServerDetail.
type FTPServerDetail struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
	Password  string `json:"Password"`
	User      string `json:"User"`
}

// FindRequest defines model for FindRequest.
type FindRequest struct {
	Count   *int      `json:"Count,omitempty"`
	Exclude *[]string `json:"Exclude,omitempty"`
	From    *int      `json:"From,omitempty"`
	Include *[]string `json:"Include,omitempty"`
	Sort    *[]string `json:"Sort,omitempty"`
}

// FindResultEnvelope defines model for FindResultEnvelope.
type FindResultEnvelope struct {
	Count int  `json:"Count"`
	From  int  `json:"From"`
	Total int  `json:"Total"`
	IsOk  bool `json:"is_ok"`
}

// ID defines model for ID.
type ID interface{}

// IDEnvelope defines model for IDEnvelope.
type IDEnvelope struct {
	ID *ID `json:"ID,omitempty"`
}

// Icon defines model for Icon.
type Icon struct {
	Availability string    `json:"Availability"`
	CreatedAt    time.Time `json:"CreatedAt"`
	ID           ID        `json:"ID"`
	ModifiedAt   time.Time `json:"ModifiedAt"`
	Name         string    `json:"Name"`
	Scope        string    `json:"Scope"`
	Tags         []string  `json:"Tags"`
	URL          string    `json:"URL"`
}

// IconCreateRequest defines model for IconCreateRequest.
type IconCreateRequest struct {
	Icon IconCreateRequestBody `json:"Icon"`
}

// IconCreateRequestBody defines model for IconCreateRequestBody.
type IconCreateRequestBody struct {
	Image string    `json:"Image"`
	Name  string    `json:"Name"`
	Tags  *[]string `json:"Tags,omitempty"`
}

// IconFindFilter defines model for IconFindFilter.
type IconFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	Scope                *Scope                 `json:"Scope,omitempty"`
	TagsName             *[]string              `json:"Tags.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconFindRequest defines model for IconFindRequest.
type IconFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *IconFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconMultiResponse defines model for IconMultiResponse.
type IconMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconsWrapper)
	IconsWrapper `yaml:",inline"`
}

// IconSingleResponse defines model for IconSingleResponse.
type IconSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconWrapper)
	IconWrapper `yaml:",inline"`
}

// IconUpdateRequest defines model for IconUpdateRequest.
type IconUpdateRequest struct {
	Icon IconUpdateRequestBody `json:"Icon"`
}

// IconUpdateRequestBody defines model for IconUpdateRequestBody.
type IconUpdateRequestBody struct {
	Name *string   `json:"Name,omitempty"`
	Tags *[]string `json:"Tags,omitempty"`
}

// IconView defines model for IconView.
type IconView struct {
	ID    ID     `json:"ID"`
	Name  string `json:"Name"`
	Scope string `json:"Scope"`
	URL   string `json:"URL"`
}

// IconWrapper defines model for IconWrapper.
type IconWrapper struct {
	Icon Icon `json:"Icon"`
}

// Icons defines model for Icons.
type Icons []struct {
	// Embedded struct due to allOf(#/components/schemas/Icon)
	Icon `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// IconsWrapper defines model for IconsWrapper.
type IconsWrapper struct {
	Icons Icons `json:"Icons"`
}

// Region defines model for Region.
type Region struct {
	Description string   `json:"Description"`
	ID          int      `json:"ID"`
	Name        string   `json:"Name"`
	NameServers []string `json:"NameServers"`
}

// RegionFindFilter defines model for RegionFindFilter.
type RegionFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionFindRequest defines model for RegionFindRequest.
type RegionFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *RegionFindFilter      `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionMultiResponse defines model for RegionMultiResponse.
type RegionMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionsWrapper)
	RegionsWrapper `yaml:",inline"`
}

// RegionSingleResponse defines model for RegionSingleResponse.
type RegionSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionWrapper)
	RegionWrapper `yaml:",inline"`
}

// RegionWrapper defines model for RegionWrapper.
type RegionWrapper struct {
	Region Region `json:"Region"`
}

// Regions defines model for Regions.
type Regions []struct {
	// Embedded struct due to allOf(#/components/schemas/Region)
	Region `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// RegionsWrapper defines model for RegionsWrapper.
type RegionsWrapper struct {
	Regions Regions `json:"Regions"`
}

// Scope defines model for Scope.
type Scope string

// List of Scope
const (
	Scope_shared Scope = "shared"
	Scope_user   Scope = "user"
)

// VNCProxy defines model for VNCProxy.
type VNCProxy struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// Zone defines model for Zone.
type Zone struct {
	CreatedAt    time.Time `json:"CreatedAt"`
	Description  string    `json:"Description"`
	DisplayOrder int       `json:"DisplayOrder"`
	FTPServer    FTPServer `json:"FTPServer"`
	ID           ID        `json:"ID"`
	IsDummy      bool      `json:"IsDummy"`
	Name         string    `json:"Name"`
	Region       Region    `json:"Region"`
	VNCProxy     VNCProxy  `json:"VNCProxy"`
}

// ZoneFindFilter defines model for ZoneFindFilter.
type ZoneFindFilter struct {
	ID                   *[]string              `json:"ID,omitempty"`
	Name                 *[]string              `json:"Name,omitempty"`
	RegionID             *[]string              `json:"Region.ID,omitempty"`
	RegionName           *[]string              `json:"Region.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneFindRequest defines model for ZoneFindRequest.
type ZoneFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *ZoneFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneMultiResponse defines model for ZoneMultiResponse.
type ZoneMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZonesWrapper)
	ZonesWrapper `yaml:",inline"`
}

// ZoneSingleResponse defines model for ZoneSingleResponse.
type ZoneSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZoneWrapper)
	ZoneWrapper `yaml:",inline"`
}

// ZoneWrapper defines model for ZoneWrapper.
type ZoneWrapper struct {
	Zone Zone `json:"Zone"`
}

// Zones defines model for Zones.
type Zones []struct {
	// Embedded struct due to allOf(#/components/schemas/Zone)
	Zone `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// ZonesWrapper defines model for ZonesWrapper.
type ZonesWrapper struct {
	Zones Zones `json:"Zones"`
}

// BadRequest defines model for BadRequest.
type BadRequest APIError

// Conflict defines model for Conflict.
type Conflict APIError

// Forbidden defines model for Forbidden.
type Forbidden APIError

// InternalServerError defines model for InternalServerError.
type InternalServerError APIError

// Locked defines model for Locked.
type Locked APIError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed APIError

// NotFound defines model for NotFound.
type NotFound APIError

// ServiceUnavailable defines model for ServiceUnavailable.
type ServiceUnavailable APIError

// Unauthorized defines model for Unauthorized.
type Unauthorized APIError

// UnexpectedError defines model for UnexpectedError.
type UnexpectedError APIError

// CreateCDROMJSONBody defines parameters for CreateCDROM.
type CreateCDROMJSONBody CDROMCreateRequest

// UpdateCDROMByIdJSONBody defines parameters for UpdateCDROMById.
type UpdateCDROMByIdJSONBody CDROMUpdateRequest

// CreateIconJSONBody defines parameters for CreateIcon.
type CreateIconJSONBody IconCreateRequest

// UpdateIconByIdJSONBody defines parameters for UpdateIconById.
type UpdateIconByIdJSONBody IconUpdateRequest

// CreateCDROMJSONRequestBody defines body for CreateCDROM for application/json ContentType.
type CreateCDROMJSONRequestBody CreateCDROMJSONBody

// UpdateCDROMByIdJSONRequestBody defines body for UpdateCDROMById for application/json ContentType.
type UpdateCDROMByIdJSONRequestBody UpdateCDROMByIdJSONBody

// CreateIconJSONRequestBody defines body for CreateIcon for application/json ContentType.
type CreateIconJSONRequestBody CreateIconJSONBody

// UpdateIconByIdJSONRequestBody defines body for UpdateIconById for application/json ContentType.
type UpdateIconByIdJSONRequestBody UpdateIconByIdJSONBody

// Getter for additional properties for CDROMFilter. Returns the specified
// element and whether it was found
func (a CDROMFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CDROMFilter
func (a *CDROMFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CDROMFilter to handle AdditionalProperties
func (a *CDROMFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Scope"]; found {
		err = json.Unmarshal(raw, &a.Scope)
		if err != nil {
			return errors.Wrap(err, "error reading 'Scope'")
		}
		delete(object, "Scope")
	}

	if raw, found := object["Tags.Name"]; found {
		err = json.Unmarshal(raw, &a.TagsName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Tags.Name'")
		}
		delete(object, "Tags.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CDROMFilter to handle AdditionalProperties
func (a CDROMFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.Scope != nil {
		object["Scope"], err = json.Marshal(a.Scope)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Scope'"))
		}
	}

	if a.TagsName != nil {
		object["Tags.Name"], err = json.Marshal(a.TagsName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Tags.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CDROMFindRequest. Returns the specified
// element and whether it was found
func (a CDROMFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CDROMFindRequest
func (a *CDROMFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CDROMFindRequest to handle AdditionalProperties
func (a *CDROMFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CDROMFindRequest to handle AdditionalProperties
func (a CDROMFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IconFindFilter. Returns the specified
// element and whether it was found
func (a IconFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindFilter
func (a *IconFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a *IconFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Scope"]; found {
		err = json.Unmarshal(raw, &a.Scope)
		if err != nil {
			return errors.Wrap(err, "error reading 'Scope'")
		}
		delete(object, "Scope")
	}

	if raw, found := object["Tags.Name"]; found {
		err = json.Unmarshal(raw, &a.TagsName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Tags.Name'")
		}
		delete(object, "Tags.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a IconFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.Scope != nil {
		object["Scope"], err = json.Marshal(a.Scope)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Scope'"))
		}
	}

	if a.TagsName != nil {
		object["Tags.Name"], err = json.Marshal(a.TagsName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Tags.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IconFindRequest. Returns the specified
// element and whether it was found
func (a IconFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindRequest
func (a *IconFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a *IconFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a IconFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindFilter. Returns the specified
// element and whether it was found
func (a RegionFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindFilter
func (a *RegionFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a *RegionFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a RegionFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindRequest. Returns the specified
// element and whether it was found
func (a RegionFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindRequest
func (a *RegionFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a *RegionFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a RegionFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindFilter. Returns the specified
// element and whether it was found
func (a ZoneFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindFilter
func (a *ZoneFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a *ZoneFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ID"]; found {
		err = json.Unmarshal(raw, &a.ID)
		if err != nil {
			return errors.Wrap(err, "error reading 'ID'")
		}
		delete(object, "ID")
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Region.ID"]; found {
		err = json.Unmarshal(raw, &a.RegionID)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.ID'")
		}
		delete(object, "Region.ID")
	}

	if raw, found := object["Region.Name"]; found {
		err = json.Unmarshal(raw, &a.RegionName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.Name'")
		}
		delete(object, "Region.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a ZoneFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ID != nil {
		object["ID"], err = json.Marshal(a.ID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'ID'"))
		}
	}

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.RegionID != nil {
		object["Region.ID"], err = json.Marshal(a.RegionID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.ID'"))
		}
	}

	if a.RegionName != nil {
		object["Region.Name"], err = json.Marshal(a.RegionName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindRequest. Returns the specified
// element and whether it was found
func (a ZoneFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindRequest
func (a *ZoneFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a *ZoneFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a ZoneFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateCDROM request  with any body
	CreateCDROMWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCDROM(ctx context.Context, body CreateCDROMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCDROMById request
	DeleteCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowCDROMById request
	ShowCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCDROMById request  with any body
	UpdateCDROMByIdWithBody(ctx context.Context, cdromId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCDROMById(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCDROMs request
	ListCDROMs(ctx context.Context, params CDROMFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIcon request  with any body
	CreateIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIcon(ctx context.Context, body CreateIconJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIconById request
	DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowIconById request
	ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIcons request
	ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowRegionById request
	ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegions request
	ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowZoneById request
	ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListZones request
	ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateCDROMWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCDROMRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCDROM(ctx context.Context, body CreateCDROMJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCDROMRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCDROMByIdRequest(c.Server, cdromId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowCDROMById(ctx context.Context, cdromId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowCDROMByIdRequest(c.Server, cdromId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCDROMByIdWithBody(ctx context.Context, cdromId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCDROMByIdRequestWithBody(c.Server, cdromId, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCDROMById(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCDROMByIdRequest(c.Server, cdromId, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCDROMs(ctx context.Context, params CDROMFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCDROMsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIcon(ctx context.Context, body CreateIconJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequestWithBody(c.Server, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequest(c.Server, iconId, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIconsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRegionByIdRequest(c.Server, regionId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowZoneByIdRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateCDROMRequest calls the generic CreateCDROM builder with application/json body
func NewCreateCDROMRequest(server string, body CreateCDROMJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCDROMRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCDROMRequestWithBody generates requests for CreateCDROM with any type of body
func NewCreateCDROMRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCDROMByIdRequest generates requests for DeleteCDROMById
func NewDeleteCDROMByIdRequest(server string, cdromId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowCDROMByIdRequest generates requests for ShowCDROMById
func NewShowCDROMByIdRequest(server string, cdromId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCDROMByIdRequest calls the generic UpdateCDROMById builder with application/json body
func NewUpdateCDROMByIdRequest(server string, cdromId ID, body UpdateCDROMByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCDROMByIdRequestWithBody(server, cdromId, "application/json", bodyReader)
}

// NewUpdateCDROMByIdRequestWithBody generates requests for UpdateCDROMById with any type of body
func NewUpdateCDROMByIdRequestWithBody(server string, cdromId ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "cdromId", cdromId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCDROMsRequest generates requests for ListCDROMs
func NewListCDROMsRequest(server string, params CDROMFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/cdrom?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIconRequest calls the generic CreateIcon builder with application/json body
func NewCreateIconRequest(server string, body CreateIconJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIconRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIconRequestWithBody generates requests for CreateIcon with any type of body
func NewCreateIconRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIconByIdRequest generates requests for DeleteIconById
func NewDeleteIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowIconByIdRequest generates requests for ShowIconById
func NewShowIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIconByIdRequest calls the generic UpdateIconById builder with application/json body
func NewUpdateIconByIdRequest(server string, iconId ID, body UpdateIconByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIconByIdRequestWithBody(server, iconId, "application/json", bodyReader)
}

// NewUpdateIconByIdRequestWithBody generates requests for UpdateIconById with any type of body
func NewUpdateIconByIdRequestWithBody(server string, iconId ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIconsRequest generates requests for ListIcons
func NewListIconsRequest(server string, params IconFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowRegionByIdRequest generates requests for ShowRegionById
func NewShowRegionByIdRequest(server string, regionId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "regionId", regionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string, params RegionFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowZoneByIdRequest generates requests for ShowZoneById
func NewShowZoneByIdRequest(server string, zoneId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "zoneId", zoneId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListZonesRequest generates requests for ListZones
func NewListZonesRequest(server string, params ZoneFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	req = req.WithContext(ctx)
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateCDROM request  with any body
	CreateCDROMWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateCDROMResponse, error)

	CreateCDROMWithResponse(ctx context.Context, body CreateCDROMJSONRequestBody) (*CreateCDROMResponse, error)

	// DeleteCDROMById request
	DeleteCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*DeleteCDROMByIdResponse, error)

	// ShowCDROMById request
	ShowCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*ShowCDROMByIdResponse, error)

	// UpdateCDROMById request  with any body
	UpdateCDROMByIdWithBodyWithResponse(ctx context.Context, cdromId ID, contentType string, body io.Reader) (*UpdateCDROMByIdResponse, error)

	UpdateCDROMByIdWithResponse(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody) (*UpdateCDROMByIdResponse, error)

	// ListCDROMs request
	ListCDROMsWithResponse(ctx context.Context, params CDROMFindRequest) (*ListCDROMsResponse, error)

	// CreateIcon request  with any body
	CreateIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconResponse, error)

	CreateIconWithResponse(ctx context.Context, body CreateIconJSONRequestBody) (*CreateIconResponse, error)

	// DeleteIconById request
	DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error)

	// ShowIconById request
	ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error)

	UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error)

	// ListIcons request
	ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error)

	// ShowRegionById request
	ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error)

	// ListRegions request
	ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error)

	// ShowZoneById request
	ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error)

	// ListZones request
	ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error)
}

type CreateCDROMResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CDROMCreateResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r CreateCDROMResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCDROMResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCDROMByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r DeleteCDROMByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCDROMByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowCDROMByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowCDROMByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowCDROMByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCDROMByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateCDROMByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCDROMByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCDROMsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CDROMMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListCDROMsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCDROMsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r CreateIconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r DeleteIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListIconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowRegionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowRegionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowRegionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowZoneByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowZoneByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowZoneByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateCDROMWithBodyWithResponse request with arbitrary body returning *CreateCDROMResponse
func (c *ClientWithResponses) CreateCDROMWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateCDROMResponse, error) {
	rsp, err := c.CreateCDROMWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateCDROMResponse(rsp)
}

func (c *ClientWithResponses) CreateCDROMWithResponse(ctx context.Context, body CreateCDROMJSONRequestBody) (*CreateCDROMResponse, error) {
	rsp, err := c.CreateCDROM(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateCDROMResponse(rsp)
}

// DeleteCDROMByIdWithResponse request returning *DeleteCDROMByIdResponse
func (c *ClientWithResponses) DeleteCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*DeleteCDROMByIdResponse, error) {
	rsp, err := c.DeleteCDROMById(ctx, cdromId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCDROMByIdResponse(rsp)
}

// ShowCDROMByIdWithResponse request returning *ShowCDROMByIdResponse
func (c *ClientWithResponses) ShowCDROMByIdWithResponse(ctx context.Context, cdromId ID) (*ShowCDROMByIdResponse, error) {
	rsp, err := c.ShowCDROMById(ctx, cdromId)
	if err != nil {
		return nil, err
	}
	return ParseShowCDROMByIdResponse(rsp)
}

// UpdateCDROMByIdWithBodyWithResponse request with arbitrary body returning *UpdateCDROMByIdResponse
func (c *ClientWithResponses) UpdateCDROMByIdWithBodyWithResponse(ctx context.Context, cdromId ID, contentType string, body io.Reader) (*UpdateCDROMByIdResponse, error) {
	rsp, err := c.UpdateCDROMByIdWithBody(ctx, cdromId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCDROMByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateCDROMByIdWithResponse(ctx context.Context, cdromId ID, body UpdateCDROMByIdJSONRequestBody) (*UpdateCDROMByIdResponse, error) {
	rsp, err := c.UpdateCDROMById(ctx, cdromId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCDROMByIdResponse(rsp)
}

// ListCDROMsWithResponse request returning *ListCDROMsResponse
func (c *ClientWithResponses) ListCDROMsWithResponse(ctx context.Context, params CDROMFindRequest) (*ListCDROMsResponse, error) {
	rsp, err := c.ListCDROMs(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListCDROMsResponse(rsp)
}

// CreateIconWithBodyWithResponse request with arbitrary body returning *CreateIconResponse
func (c *ClientWithResponses) CreateIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconResponse, error) {
	rsp, err := c.CreateIconWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconResponse(rsp)
}

func (c *ClientWithResponses) CreateIconWithResponse(ctx context.Context, body CreateIconJSONRequestBody) (*CreateIconResponse, error) {
	rsp, err := c.CreateIcon(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconResponse(rsp)
}

// DeleteIconByIdWithResponse request returning *DeleteIconByIdResponse
func (c *ClientWithResponses) DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error) {
	rsp, err := c.DeleteIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIconByIdResponse(rsp)
}

// ShowIconByIdWithResponse request returning *ShowIconByIdResponse
func (c *ClientWithResponses) ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error) {
	rsp, err := c.ShowIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseShowIconByIdResponse(rsp)
}

// UpdateIconByIdWithBodyWithResponse request with arbitrary body returning *UpdateIconByIdResponse
func (c *ClientWithResponses) UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconByIdWithBody(ctx, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconById(ctx, iconId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

// ListIconsWithResponse request returning *ListIconsResponse
func (c *ClientWithResponses) ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error) {
	rsp, err := c.ListIcons(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListIconsResponse(rsp)
}

// ShowRegionByIdWithResponse request returning *ShowRegionByIdResponse
func (c *ClientWithResponses) ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error) {
	rsp, err := c.ShowRegionById(ctx, regionId)
	if err != nil {
		return nil, err
	}
	return ParseShowRegionByIdResponse(rsp)
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// ShowZoneByIdWithResponse request returning *ShowZoneByIdResponse
func (c *ClientWithResponses) ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error) {
	rsp, err := c.ShowZoneById(ctx, zoneId)
	if err != nil {
		return nil, err
	}
	return ParseShowZoneByIdResponse(rsp)
}

// ListZonesWithResponse request returning *ListZonesResponse
func (c *ClientWithResponses) ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error) {
	rsp, err := c.ListZones(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListZonesResponse(rsp)
}

// ParseCreateCDROMResponse parses an HTTP response from a CreateCDROMWithResponse call
func ParseCreateCDROMResponse(rsp *http.Response) (*CreateCDROMResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCDROMResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CDROMCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCDROMByIdResponse parses an HTTP response from a DeleteCDROMByIdWithResponse call
func ParseDeleteCDROMByIdResponse(rsp *http.Response) (*DeleteCDROMByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCDROMByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowCDROMByIdResponse parses an HTTP response from a ShowCDROMByIdWithResponse call
func ParseShowCDROMByIdResponse(rsp *http.Response) (*ShowCDROMByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowCDROMByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCDROMByIdResponse parses an HTTP response from a UpdateCDROMByIdWithResponse call
func ParseUpdateCDROMByIdResponse(rsp *http.Response) (*UpdateCDROMByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateCDROMByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCDROMsResponse parses an HTTP response from a ListCDROMsWithResponse call
func ParseListCDROMsResponse(rsp *http.Response) (*ListCDROMsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCDROMsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CDROMMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIconResponse parses an HTTP response from a CreateIconWithResponse call
func ParseCreateIconResponse(rsp *http.Response) (*CreateIconResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateIconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIconByIdResponse parses an HTTP response from a DeleteIconByIdWithResponse call
func ParseDeleteIconByIdResponse(rsp *http.Response) (*DeleteIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowIconByIdResponse parses an HTTP response from a ShowIconByIdWithResponse call
func ParseShowIconByIdResponse(rsp *http.Response) (*ShowIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateIconByIdResponse parses an HTTP response from a UpdateIconByIdWithResponse call
func ParseUpdateIconByIdResponse(rsp *http.Response) (*UpdateIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIconsResponse parses an HTTP response from a ListIconsWithResponse call
func ParseListIconsResponse(rsp *http.Response) (*ListIconsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListIconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowRegionByIdResponse parses an HTTP response from a ShowRegionByIdWithResponse call
func ParseShowRegionByIdResponse(rsp *http.Response) (*ShowRegionByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowRegionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowZoneByIdResponse parses an HTTP response from a ShowZoneByIdWithResponse call
func ParseShowZoneByIdResponse(rsp *http.Response) (*ShowZoneByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowZoneByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListZonesResponse parses an HTTP response from a ListZonesWithResponse call
func ParseListZonesResponse(rsp *http.Response) (*ListZonesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xcW2/bOhL+KwJ3H1XLSdMF1i+7bpxgjW0uSJpTYAOjYCTaZiOLOiSVNDH03xe8SBYt",
	"ypKSWHVz/NLWvM1wODMfZzTsEvhkEZMIRZyBwRJQxGISMSR/fIbBFfozQYyLXz6JOIrkP2Ech9iHHJPI",
	"+8FIJNqYP0cLKP71d4qmYAD+5q2W9lQv84aX4xNKCQVpmrogQMynOBbrgIEg52T0Uhcck2gaYr8b2jmx",
	"1AWnhN7hIEBRJ5RX1FIXjCOOaATDa0QfEFVzumAio+sowo4e6IIvxL9HQSc8aFKpC84Qn5PgnPBhGJLH",
	"jsgros454U5GNnXBOeGnJIm6YUHQVtRSF4iTwD66ieADxCG8C1EnPGiyTpFu6oKbCCZ8Tih+7ug4DIIu",
	"mCMYICq90rdv374PEz5HERdkkUmPP8UIDADjFEczsbBkHv2Mkc9R0J1FrWhmxpS6elm5i3zuYAliSmJE",
	"OVZeF4nm7z4JkGU/ru5esJm1F7PvU8hhWOi8IyREULoXhig2+lYTGYc8YTYJuoCiPxNMxcHfrgjkq+Vz",
	"3SLrRUYnbrYoufuBlJMd+kJQV4glIT+JHlBIYlSWBWbfyb1tL2WuyL2VzvHo6uKsvPBQKTcOMX+yyuOY",
	"IshRMJQqMiV0ATkYgABy9IHjhdhfacqoqACWJUeYxSF8uqABooUBOOJohqS3HY/qVG48kuN8RWLjSJ9E",
	"f2D0KB0qCfAUt9vNOVzYFfDa10e1iboaJEbjZ3T2uW64PCUxlMk5nFA4Q8chZMzKwlc4U+rB0cI+QjdA",
	"SuFTSVvGI6D3l+0m59M8RU3JNdWlqBxrp2qIem0jldqpVivctExVzTW4VoDGQp9JUN65WqsZJ3KBEjd1",
	"St5INUe5xW9UtBeozis1I1MKRblWTuquLEEkDC+mYHBbAxg2p5e6DTb4jcI4lk5i8+DTr5fqCjdCHOIQ",
	"pJOM51MccuV3YBBgwQcMLwtHy2mC3LXDzo6mqTTbOgdxWr22RNKqUznFUTFeaXYkxUlCuM2FsxJo7enp",
	"oRbW8+M5S0KO22uUYr+9PrFcoXIOrnE0C3+NUhd4eNaXoChZgMHtp4PDvnvQPzzqr2yxgJdyzk0cvI37",
	"NBZ6ifssL9DafVY6wxc4NjuTmdBfIai2cjEZb6ZVmpC7zuU4CtBP2+1pHePluInV4NadlmkRdsGwRpJh",
	"dtHYwT/31WWS/yGMV6rC+HIYBBSxBrf1fJ3irI28aNx4O45ccAkZeyQ0sHbeMOMy3GYfenKBgHVnJiqs",
	"HS1JVBBY9i0nP/0wCVrC3ykli4qrffSC5a4J5a81egtCtBFD9Y6+EjPOLHQ1DdsUXU0kW9HdEM2pACkP",
	"YHDE/3EEXEAipF1KiZeSzCZymWpZNIvBbJLOrr7bjzSbxonbiftejU0uuLn6Um/0G4IuGcEZodZaOKfj",
	"NkFnUnFUNWFX0xi7PuiSKzXiwn5nGC/gDG39tmAJgxThKs6FY3nXQUW2yZ2LKdakXxFWiFHdRRWCmhlU",
	"iJZOYwpBsMRBTXTQ1MrrY4ONVt4gMtjqzT9PBr4Q7l4EC42cvC0Xt8lrV97Sm55ku4N7SeiiqHQSuRhW",
	"ZxUJayITZhWKPVK4QjNsu+fUJgZH9rtipWKJDhWTvAbKzHRuUduK61dvtCuUSzdysHMQVBJOBQipcd3B",
	"kKJnApFq6xSKFEkLF5W2ujKr+nVLSq6bq7X4JW4so9WJI1s7twrxsGbyYRUCstt5DmA65wgSlVVgcyhm",
	"Tywx0h/nx5eU/HzagcTN/0hkC+h/xddLI5/V6CNFq2+ebJQsFk/2D9uVIm9nVubJbpqRjyulNIqfBg3s",
	"WftQuBKCCUualwIrq71XKcBLQUrJvnkg1j50U7vptSWkp70FiGby2TkIXTu4CgAVo7qDT0HNBE/R0il0",
	"CoIlDipxIXN/dSuW7FQ2VtnTS+BSUekELI1TsoqENZEJswrFBjOydMhPKOZP12IBtf4dZNgfJnyeV0xJ",
	"ryxaVwAz5zxW9VE4mpKs9Aqqsk60kN8aAIN+SJKgJ5CX/XsmWnu+TAlH0gOAM4gjDnEk7uouSGioV2YD",
	"z5thPk/uxHhPr6N3CUpFWV/nmDmYOdAJ0BRH0pyZMyXUuR7+9+Zq6ByL6c7wcsx6wAUh9pFWeM3HMIb+",
	"HDmHvb7BxsDzHh8fe1D29gideXoq876Mj0/Or08+HPb6vTlfhNJpIbpgF1NdalfYiliEwfuEwh4Mej9i",
	"D84oQgsUcU9IFPNQjC7xClwgohi1x36v3zsQVEiMIhhjMAAfe/3eR+CCGPK5PDnPD3RaPybKJa5Vw0oQ",
	"c6BzPPpwdXEG5GJUlsiNg7xffaJTGlRIa7xJaZ2lMCY1tVU4XtlQKFg+7B9shwPt+Sx1fidZlV/GiMOJ",
	"A50HGGLRllczH/X7VRTzLXiFgms55aB+ilEnKSd9rJ9k1Bwf9T/VzyiV5KYu+NRkS7aKZjm3AZuWElgp",
	"/ylMQt5ENGbZp3RjyWIB6ZNVx7lMtN0CaRwMTMR4ZSneUv41DlJlKyFSZaemKoxke2YVpsUU+j4/jQNp",
	"jBQuEJfZjdtlyVEhBwcOmTp8jhxJXOiVpix8KRhIc165SM0hWLcRt6G+y69ak5JB9d/WoNauEu/UoI7q",
	"Z+SF5a+xwKP+P+snFp82HB022MyqEP/3tnBlcxvs2wUzZEG/cTQl8lIAHRYjH0+xXwWE13Py+FqjpohT",
	"jB72Zv3ezPr3tp6NVmAxpTixmJL67mWHxELfb2A9W7rimp8nG11x96a7R+Tf1KcobW9y4/7XUjoDJi/c",
	"VpT+ghl3YBhWQbPo18WXJc/ydtZjJAlVlqPkhNROSj5o+6hs5g0tlj2MHJlUEl5ViZHtY9UdtJuyrlst",
	"B2cFiJuTOnKYPaUzVl3bgLtyyV3HCR1LPdI+n/MO8zlavTMLwaqSJTcQbyn+bJTKGdsMZdXV/tYqKNfl",
	"cRR3uxvv/XXMaH9n3KEszthu1S1SOFZrvp6Tx9fZ8uYAdG/N++TNjiRvKi1oQ+bGajOrrp23mu1cY39p",
	"0mZvsXv8/QU5m/HmW3WLfI0qLbela7KebWRr1h/z7FKypvxSpyZXo6S/j0J3OFOT6bLNYKisbvSW6m8d",
	"ija+x+YFouWbrOpqj8qKkXpczhje3fustdZ/j4/v80abW0JmZDQr8y+YWQtkyl4J2LBp1bcNdCq/9Nkl",
	"fLI94qlBqOwk9hi1wxi10mm7AT2TCHlL8WdbjJLF0DaEEh3t8UmwUI9OitHdxSZLKf0emd4nMmn9z8zq",
	"WdXV50bVApNUSb4NkbKebeDR+qOZXUKj8ouYGixS0t8j0Q4jUabLJYMpvDyR2l14c3I7EWrGshfit8u1",
	"dyFyHjLfU6jnIStcSz0YY9160DsALniAFItdSrV91q+LspehmB1A+f8THdwJZu/lL36f/XoAk4Jo1OhU",
	"Yore19KoSxMbNrX2IjNy9ShFfe0XQEAS6qvXRYUMae18EYNaZ9Mc+DfOV/cD6wrP+sA2zhenWpg9Sf8f",
	"AAD//5UmgMJuXgAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

