// Package sacloud provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package sacloud

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/pkg/errors"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// APIError defines model for APIError.
type APIError struct {
	ErrorCode string `json:"error_code"`
	ErrorMsg  string `json:"error_msg"`
	IsFatal   bool   `json:"is_fatal"`
	Serial    string `json:"serial"`
	Status    string `json:"status"`
}

// ActionResultEnvelope defines model for ActionResultEnvelope.
type ActionResultEnvelope struct {
	IsOk bool `json:"is_ok"`
}

// FTPServer defines model for FTPServer.
type FTPServer struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// FindRequest defines model for FindRequest.
type FindRequest struct {
	Count   *int      `json:"Count,omitempty"`
	Exclude *[]string `json:"Exclude,omitempty"`
	From    *int      `json:"From,omitempty"`
	Include *[]string `json:"Include,omitempty"`
	Sort    *[]string `json:"Sort,omitempty"`
}

// FindResultEnvelope defines model for FindResultEnvelope.
type FindResultEnvelope struct {
	Count int  `json:"Count"`
	From  int  `json:"From"`
	Total int  `json:"Total"`
	IsOk  bool `json:"is_ok"`
}

// ID defines model for ID.
type ID interface{}

// Icon defines model for Icon.
type Icon struct {
	Availability string    `json:"Availability"`
	CreatedAt    time.Time `json:"CreatedAt"`
	ID           ID        `json:"ID"`
	ModifiedAt   time.Time `json:"ModifiedAt"`
	Name         string    `json:"Name"`
	Scope        string    `json:"Scope"`
	Tags         []string  `json:"Tags"`
	URL          string    `json:"URL"`
}

// IconCreateRequest defines model for IconCreateRequest.
type IconCreateRequest struct {
	Icon IconCreateRequestBody `json:"Icon"`
}

// IconCreateRequestBody defines model for IconCreateRequestBody.
type IconCreateRequestBody struct {
	Image string    `json:"Image"`
	Name  string    `json:"Name"`
	Tags  *[]string `json:"Tags,omitempty"`
}

// IconFindFilter defines model for IconFindFilter.
type IconFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	Scope                *Scope                 `json:"Scope,omitempty"`
	TagsName             *[]string              `json:"Tags.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconFindRequest defines model for IconFindRequest.
type IconFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *IconFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IconMultiResponse defines model for IconMultiResponse.
type IconMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconsWrapper)
	IconsWrapper `yaml:",inline"`
}

// IconSingleResponse defines model for IconSingleResponse.
type IconSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/IconWrapper)
	IconWrapper `yaml:",inline"`
}

// IconUpdateRequest defines model for IconUpdateRequest.
type IconUpdateRequest struct {
	Icon IconUpdateRequestBody `json:"Icon"`
}

// IconUpdateRequestBody defines model for IconUpdateRequestBody.
type IconUpdateRequestBody struct {
	Name *string   `json:"Name,omitempty"`
	Tags *[]string `json:"Tags,omitempty"`
}

// IconWrapper defines model for IconWrapper.
type IconWrapper struct {
	Icon Icon `json:"Icon"`
}

// Icons defines model for Icons.
type Icons []struct {
	// Embedded struct due to allOf(#/components/schemas/Icon)
	Icon `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// IconsWrapper defines model for IconsWrapper.
type IconsWrapper struct {
	Icons Icons `json:"Icons"`
}

// Region defines model for Region.
type Region struct {
	Description string   `json:"Description"`
	ID          int      `json:"ID"`
	Name        string   `json:"Name"`
	NameServers []string `json:"NameServers"`
}

// RegionFindFilter defines model for RegionFindFilter.
type RegionFindFilter struct {
	Name                 *[]string              `json:"Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionFindRequest defines model for RegionFindRequest.
type RegionFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *RegionFindFilter      `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegionMultiResponse defines model for RegionMultiResponse.
type RegionMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionsWrapper)
	RegionsWrapper `yaml:",inline"`
}

// RegionSingleResponse defines model for RegionSingleResponse.
type RegionSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/RegionWrapper)
	RegionWrapper `yaml:",inline"`
}

// RegionWrapper defines model for RegionWrapper.
type RegionWrapper struct {
	Region Region `json:"Region"`
}

// Regions defines model for Regions.
type Regions []struct {
	// Embedded struct due to allOf(#/components/schemas/Region)
	Region `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// RegionsWrapper defines model for RegionsWrapper.
type RegionsWrapper struct {
	Regions Regions `json:"Regions"`
}

// Scope defines model for Scope.
type Scope string

// List of Scope
const (
	Scope_shared Scope = "shared"
	Scope_user   Scope = "user"
)

// VNCProxy defines model for VNCProxy.
type VNCProxy struct {
	HostName  string `json:"HostName"`
	IPAddress string `json:"IPAddress"`
}

// Zone defines model for Zone.
type Zone struct {
	CreatedAt    time.Time `json:"CreatedAt"`
	Description  string    `json:"Description"`
	DisplayOrder int       `json:"DisplayOrder"`
	FTPServer    FTPServer `json:"FTPServer"`
	ID           ID        `json:"ID"`
	IsDummy      bool      `json:"IsDummy"`
	Name         string    `json:"Name"`
	Region       Region    `json:"Region"`
	VNCProxy     VNCProxy  `json:"VNCProxy"`
}

// ZoneFindFilter defines model for ZoneFindFilter.
type ZoneFindFilter struct {
	ID                   *[]string              `json:"ID,omitempty"`
	Name                 *[]string              `json:"Name,omitempty"`
	RegionID             *[]string              `json:"Region.ID,omitempty"`
	RegionName           *[]string              `json:"Region.Name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneFindRequest defines model for ZoneFindRequest.
type ZoneFindRequest struct {
	// Embedded struct due to allOf(#/components/schemas/FindRequest)
	FindRequest `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Filter               *ZoneFindFilter        `json:"Filter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ZoneMultiResponse defines model for ZoneMultiResponse.
type ZoneMultiResponse struct {
	// Embedded struct due to allOf(#/components/schemas/FindResultEnvelope)
	FindResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZonesWrapper)
	ZonesWrapper `yaml:",inline"`
}

// ZoneSingleResponse defines model for ZoneSingleResponse.
type ZoneSingleResponse struct {
	// Embedded struct due to allOf(#/components/schemas/ActionResultEnvelope)
	ActionResultEnvelope `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/ZoneWrapper)
	ZoneWrapper `yaml:",inline"`
}

// ZoneWrapper defines model for ZoneWrapper.
type ZoneWrapper struct {
	Zone Zone `json:"Zone"`
}

// Zones defines model for Zones.
type Zones []struct {
	// Embedded struct due to allOf(#/components/schemas/Zone)
	Zone `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Index int `json:"Index"`
}

// ZonesWrapper defines model for ZonesWrapper.
type ZonesWrapper struct {
	Zones Zones `json:"Zones"`
}

// BadRequest defines model for BadRequest.
type BadRequest APIError

// Conflict defines model for Conflict.
type Conflict APIError

// Forbidden defines model for Forbidden.
type Forbidden APIError

// InternalServerError defines model for InternalServerError.
type InternalServerError APIError

// Locked defines model for Locked.
type Locked APIError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed APIError

// NotFound defines model for NotFound.
type NotFound APIError

// ServiceUnavailable defines model for ServiceUnavailable.
type ServiceUnavailable APIError

// Unauthorized defines model for Unauthorized.
type Unauthorized APIError

// UnexpectedError defines model for UnexpectedError.
type UnexpectedError APIError

// CreateIconsJSONBody defines parameters for CreateIcons.
type CreateIconsJSONBody IconCreateRequest

// UpdateIconByIdJSONBody defines parameters for UpdateIconById.
type UpdateIconByIdJSONBody IconUpdateRequest

// CreateIconsJSONRequestBody defines body for CreateIcons for application/json ContentType.
type CreateIconsJSONRequestBody CreateIconsJSONBody

// UpdateIconByIdJSONRequestBody defines body for UpdateIconById for application/json ContentType.
type UpdateIconByIdJSONRequestBody UpdateIconByIdJSONBody

// Getter for additional properties for IconFindFilter. Returns the specified
// element and whether it was found
func (a IconFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindFilter
func (a *IconFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a *IconFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Scope"]; found {
		err = json.Unmarshal(raw, &a.Scope)
		if err != nil {
			return errors.Wrap(err, "error reading 'Scope'")
		}
		delete(object, "Scope")
	}

	if raw, found := object["Tags.Name"]; found {
		err = json.Unmarshal(raw, &a.TagsName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Tags.Name'")
		}
		delete(object, "Tags.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindFilter to handle AdditionalProperties
func (a IconFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.Scope != nil {
		object["Scope"], err = json.Marshal(a.Scope)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Scope'"))
		}
	}

	if a.TagsName != nil {
		object["Tags.Name"], err = json.Marshal(a.TagsName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Tags.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IconFindRequest. Returns the specified
// element and whether it was found
func (a IconFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IconFindRequest
func (a *IconFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a *IconFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IconFindRequest to handle AdditionalProperties
func (a IconFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindFilter. Returns the specified
// element and whether it was found
func (a RegionFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindFilter
func (a *RegionFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a *RegionFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindFilter to handle AdditionalProperties
func (a RegionFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegionFindRequest. Returns the specified
// element and whether it was found
func (a RegionFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegionFindRequest
func (a *RegionFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a *RegionFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegionFindRequest to handle AdditionalProperties
func (a RegionFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindFilter. Returns the specified
// element and whether it was found
func (a ZoneFindFilter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindFilter
func (a *ZoneFindFilter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a *ZoneFindFilter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ID"]; found {
		err = json.Unmarshal(raw, &a.ID)
		if err != nil {
			return errors.Wrap(err, "error reading 'ID'")
		}
		delete(object, "ID")
	}

	if raw, found := object["Name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return errors.Wrap(err, "error reading 'Name'")
		}
		delete(object, "Name")
	}

	if raw, found := object["Region.ID"]; found {
		err = json.Unmarshal(raw, &a.RegionID)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.ID'")
		}
		delete(object, "Region.ID")
	}

	if raw, found := object["Region.Name"]; found {
		err = json.Unmarshal(raw, &a.RegionName)
		if err != nil {
			return errors.Wrap(err, "error reading 'Region.Name'")
		}
		delete(object, "Region.Name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindFilter to handle AdditionalProperties
func (a ZoneFindFilter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ID != nil {
		object["ID"], err = json.Marshal(a.ID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'ID'"))
		}
	}

	if a.Name != nil {
		object["Name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Name'"))
		}
	}

	if a.RegionID != nil {
		object["Region.ID"], err = json.Marshal(a.RegionID)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.ID'"))
		}
	}

	if a.RegionName != nil {
		object["Region.Name"], err = json.Marshal(a.RegionName)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Region.Name'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ZoneFindRequest. Returns the specified
// element and whether it was found
func (a ZoneFindRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ZoneFindRequest
func (a *ZoneFindRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a *ZoneFindRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["Filter"]; found {
		err = json.Unmarshal(raw, &a.Filter)
		if err != nil {
			return errors.Wrap(err, "error reading 'Filter'")
		}
		delete(object, "Filter")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ZoneFindRequest to handle AdditionalProperties
func (a ZoneFindRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Filter != nil {
		object["Filter"], err = json.Marshal(a.Filter)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling 'Filter'"))
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateIcons request  with any body
	CreateIconsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIcons(ctx context.Context, body CreateIconsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIconById request
	DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowIconById request
	ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIcons request
	ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowRegionById request
	ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegions request
	ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowZoneById request
	ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListZones request
	ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateIconsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIcons(ctx context.Context, body CreateIconsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIconsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowIconById(ctx context.Context, iconId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowIconByIdRequest(c.Server, iconId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconByIdWithBody(ctx context.Context, iconId ID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequestWithBody(c.Server, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIconById(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIconByIdRequest(c.Server, iconId, body)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIcons(ctx context.Context, params IconFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIconsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowRegionById(ctx context.Context, regionId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRegionByIdRequest(c.Server, regionId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegions(ctx context.Context, params RegionFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowZoneById(ctx context.Context, zoneId ID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowZoneByIdRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListZones(ctx context.Context, params ZoneFindRequest, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateIconsRequest calls the generic CreateIcons builder with application/json body
func NewCreateIconsRequest(server string, body CreateIconsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIconsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIconsRequestWithBody generates requests for CreateIcons with any type of body
func NewCreateIconsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIconByIdRequest generates requests for DeleteIconById
func NewDeleteIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowIconByIdRequest generates requests for ShowIconById
func NewShowIconByIdRequest(server string, iconId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIconByIdRequest calls the generic UpdateIconById builder with application/json body
func NewUpdateIconByIdRequest(server string, iconId ID, body UpdateIconByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIconByIdRequestWithBody(server, iconId, "application/json", bodyReader)
}

// NewUpdateIconByIdRequestWithBody generates requests for UpdateIconById with any type of body
func NewUpdateIconByIdRequestWithBody(server string, iconId ID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "iconId", iconId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIconsRequest generates requests for ListIcons
func NewListIconsRequest(server string, params IconFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/icon?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowRegionByIdRequest generates requests for ShowRegionById
func NewShowRegionByIdRequest(server string, regionId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "regionId", regionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string, params RegionFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/region?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowZoneByIdRequest generates requests for ShowZoneById
func NewShowZoneByIdRequest(server string, zoneId ID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "zoneId", zoneId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListZonesRequest generates requests for ListZones
func NewListZonesRequest(server string, params ZoneFindRequest) (*http.Request, error) {
	var err error

	var pathParam0 string

	var pathParamBuf0 []byte
	pathParamBuf0, err = json.Marshal(params)
	if err != nil {
		return nil, err
	}
	pathParam0 = string(pathParamBuf0)

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/zone?%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	req = req.WithContext(ctx)
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateIcons request  with any body
	CreateIconsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconsResponse, error)

	CreateIconsWithResponse(ctx context.Context, body CreateIconsJSONRequestBody) (*CreateIconsResponse, error)

	// DeleteIconById request
	DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error)

	// ShowIconById request
	ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error)

	// UpdateIconById request  with any body
	UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error)

	UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error)

	// ListIcons request
	ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error)

	// ShowRegionById request
	ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error)

	// ListRegions request
	ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error)

	// ShowZoneById request
	ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error)

	// ListZones request
	ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error)
}

type CreateIconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r CreateIconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r DeleteIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIconByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON405      *APIError
	JSON409      *APIError
	JSON423      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateIconByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIconByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IconMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListIconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowRegionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowRegionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowRegionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowZoneByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneSingleResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON404      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ShowZoneByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowZoneByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneMultiResponse
	JSON400      *APIError
	JSON401      *APIError
	JSON403      *APIError
	JSON405      *APIError
	JSON500      *APIError
	JSON503      *APIError
	JSONDefault  *APIError
}

// Status returns HTTPResponse.Status
func (r ListZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateIconsWithBodyWithResponse request with arbitrary body returning *CreateIconsResponse
func (c *ClientWithResponses) CreateIconsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateIconsResponse, error) {
	rsp, err := c.CreateIconsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconsResponse(rsp)
}

func (c *ClientWithResponses) CreateIconsWithResponse(ctx context.Context, body CreateIconsJSONRequestBody) (*CreateIconsResponse, error) {
	rsp, err := c.CreateIcons(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateIconsResponse(rsp)
}

// DeleteIconByIdWithResponse request returning *DeleteIconByIdResponse
func (c *ClientWithResponses) DeleteIconByIdWithResponse(ctx context.Context, iconId ID) (*DeleteIconByIdResponse, error) {
	rsp, err := c.DeleteIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIconByIdResponse(rsp)
}

// ShowIconByIdWithResponse request returning *ShowIconByIdResponse
func (c *ClientWithResponses) ShowIconByIdWithResponse(ctx context.Context, iconId ID) (*ShowIconByIdResponse, error) {
	rsp, err := c.ShowIconById(ctx, iconId)
	if err != nil {
		return nil, err
	}
	return ParseShowIconByIdResponse(rsp)
}

// UpdateIconByIdWithBodyWithResponse request with arbitrary body returning *UpdateIconByIdResponse
func (c *ClientWithResponses) UpdateIconByIdWithBodyWithResponse(ctx context.Context, iconId ID, contentType string, body io.Reader) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconByIdWithBody(ctx, iconId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateIconByIdWithResponse(ctx context.Context, iconId ID, body UpdateIconByIdJSONRequestBody) (*UpdateIconByIdResponse, error) {
	rsp, err := c.UpdateIconById(ctx, iconId, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIconByIdResponse(rsp)
}

// ListIconsWithResponse request returning *ListIconsResponse
func (c *ClientWithResponses) ListIconsWithResponse(ctx context.Context, params IconFindRequest) (*ListIconsResponse, error) {
	rsp, err := c.ListIcons(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListIconsResponse(rsp)
}

// ShowRegionByIdWithResponse request returning *ShowRegionByIdResponse
func (c *ClientWithResponses) ShowRegionByIdWithResponse(ctx context.Context, regionId ID) (*ShowRegionByIdResponse, error) {
	rsp, err := c.ShowRegionById(ctx, regionId)
	if err != nil {
		return nil, err
	}
	return ParseShowRegionByIdResponse(rsp)
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, params RegionFindRequest) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// ShowZoneByIdWithResponse request returning *ShowZoneByIdResponse
func (c *ClientWithResponses) ShowZoneByIdWithResponse(ctx context.Context, zoneId ID) (*ShowZoneByIdResponse, error) {
	rsp, err := c.ShowZoneById(ctx, zoneId)
	if err != nil {
		return nil, err
	}
	return ParseShowZoneByIdResponse(rsp)
}

// ListZonesWithResponse request returning *ListZonesResponse
func (c *ClientWithResponses) ListZonesWithResponse(ctx context.Context, params ZoneFindRequest) (*ListZonesResponse, error) {
	rsp, err := c.ListZones(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListZonesResponse(rsp)
}

// ParseCreateIconsResponse parses an HTTP response from a CreateIconsWithResponse call
func ParseCreateIconsResponse(rsp *http.Response) (*CreateIconsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateIconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIconByIdResponse parses an HTTP response from a DeleteIconByIdWithResponse call
func ParseDeleteIconByIdResponse(rsp *http.Response) (*DeleteIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowIconByIdResponse parses an HTTP response from a ShowIconByIdWithResponse call
func ParseShowIconByIdResponse(rsp *http.Response) (*ShowIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateIconByIdResponse parses an HTTP response from a UpdateIconByIdWithResponse call
func ParseUpdateIconByIdResponse(rsp *http.Response) (*UpdateIconByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateIconByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 423:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON423 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIconsResponse parses an HTTP response from a ListIconsWithResponse call
func ParseListIconsResponse(rsp *http.Response) (*ListIconsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListIconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IconMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowRegionByIdResponse parses an HTTP response from a ShowRegionByIdWithResponse call
func ParseShowRegionByIdResponse(rsp *http.Response) (*ShowRegionByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowRegionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowZoneByIdResponse parses an HTTP response from a ShowZoneByIdWithResponse call
func ParseShowZoneByIdResponse(rsp *http.Response) (*ShowZoneByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShowZoneByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneSingleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListZonesResponse parses an HTTP response from a ListZonesWithResponse call
func ParseListZonesResponse(rsp *http.Response) (*ListZonesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneMultiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"PzJnxz8AAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

